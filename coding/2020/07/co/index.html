<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>C&#43;&#43; 基础库 CO 参考文档 v1.2 - Alvin&#39;s Blog</title>
    <meta property="og:title" content="C&#43;&#43; 基础库 CO 参考文档 v1.2 - Alvin&#39;s Blog">
    

    
    <meta property="keywords" content ="idealvin,co,libco,coroutine,golang,C&#43;&#43;,log,logging,flag,config,json,unit-test,rpc,http,go-style,golang风格,协程,协程库,日志库,命令行,配置文件,基础库">
    

    <meta name="twitter:card" content="summary">
    
      
    

    
      
      <meta property="og:description" content="CO 是一个优雅、高效的 C&#43;&#43; 基础库，支持 Linux, Windows 与 Mac 平台。本文档将介绍 CO 的功能组件及使用方法。
[&amp;hellip;] CO 追求极简、高效，不依赖于 boost 等三方库，仅使用了少量的 C&#43;&#43;11 特性。
[&amp;hellip;] include: co/def.h.
[&amp;hellip;] int8 int16 int32 int64 uint8 &amp;hellip;">
      
    

    
    

    
    <link rel="icon" href="/favicon.ico">
    
<link href='/css/code.css' rel='stylesheet' type='text/css' />


    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/custom.css" />    
    
  </head>

  
  
  
  
  <body class="coding">
    <header class="masthead">
      <h1><a href="/" style="border: none;"><img src="/images/logo.jpg" alt="Alvin Yih"></a></h1>



      <nav class="menu">
  <input id="menu-check" type="checkbox" />
  <label id="menu-label" for="menu-check" class="unselectable">
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li>
    <a href="/">主页</a>
  </li>
  
  <li>
    <a href="/about/">关于</a>
  </li>
  
  <li class="active">
    <a href="/coding/">编程</a>
  </li>
  
  <li>
    <a href="/essay/">随笔</a>
  </li>
  
  <li>
    <a href="/donate/">捐赠</a>
  </li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      <h1>C&#43;&#43; 基础库 CO 参考文档 v1.2</h1>

<h3>Alvin
  /  2020-07-23</h3>
<hr>
      </header>



<div class="toc">
<nav id="TableOfContents">
  <ul>
    <li><a href="#1-概览">1. 概览</a></li>
    <li><a href="#2-基本定义def">2. 基本定义(def)</a>
      <ul>
        <li><a href="#21-定长整数类型">2.1 定长整数类型</a></li>
        <li><a href="#22-读写-1248-字节">2.2 读写 1、2、4、8 字节</a></li>
        <li><a href="#23-disallow_copy_and_assign">2.3 DISALLOW_COPY_AND_ASSIGN</a></li>
        <li><a href="#24-force_cast-强制类型转换">2.4 force_cast 强制类型转换</a></li>
        <li><a href="#25-__forceinline-与-__thread">2.5 __forceinline 与 __thread</a></li>
        <li><a href="#26-unlikely">2.6 unlikely</a></li>
      </ul>
    </li>
    <li><a href="#3-原子操作atomic">3. 原子操作(atomic)</a></li>
    <li><a href="#4-随机数生成器random">4. 随机数生成器(random)</a></li>
    <li><a href="#5-lrumap">5. LruMap</a></li>
    <li><a href="#6-基本类型快速转字符串fast">6. 基本类型快速转字符串(fast)</a></li>
    <li><a href="#7-高效字符流fastream">7. 高效字符流(fastream)</a></li>
    <li><a href="#8-高效字符串fastring">8. 高效字符串(fastring)</a></li>
    <li><a href="#9-字符串操作str">9. 字符串操作(str)</a>
      <ul>
        <li><a href="#91-切分字符串split">9.1 切分字符串(split)</a></li>
        <li><a href="#92-修剪字符串strip">9.2 修剪字符串(strip)</a></li>
        <li><a href="#93-替换子串replace">9.3 替换子串(replace)</a></li>
        <li><a href="#94-字符串转内置类型">9.4 字符串转内置类型</a></li>
        <li><a href="#95-内置类型转字符串">9.5 内置类型转字符串</a></li>
        <li><a href="#96-debug-string">9.6 debug string</a></li>
      </ul>
    </li>
    <li><a href="#10-命令行参数与配置文件解析库flag">10. 命令行参数与配置文件解析库(flag)</a>
      <ul>
        <li><a href="#101-基本概念">10.1 基本概念</a></li>
        <li><a href="#102-flag-库的初始化">10.2 flag 库的初始化</a></li>
        <li><a href="#103-代码中定义声明及使用-flag-变量">10.3 代码中定义、声明及使用 flag 变量</a></li>
        <li><a href="#104-命令行中使用-flag">10.4 命令行中使用 flag</a></li>
        <li><a href="#105-程序启动时指定配置文件">10.5 程序启动时指定配置文件</a></li>
        <li><a href="#106-自动生成配置文件">10.6 自动生成配置文件</a></li>
        <li><a href="#107-配置文件的格式">10.7 配置文件的格式</a></li>
      </ul>
    </li>
    <li><a href="#11-高效流式日志库log">11. 高效流式日志库(log)</a>
      <ul>
        <li><a href="#111-基本介绍">11.1 基本介绍</a></li>
        <li><a href="#112-api-介绍">11.2 Api 介绍</a></li>
        <li><a href="#113-打印不同级别的日志">11.3 打印不同级别的日志</a></li>
        <li><a href="#114-条件日志log_if">11.4 条件日志(LOG_IF)</a></li>
        <li><a href="#115-每-n-条打印一次日志log_every_n">11.5 每 N 条打印一次日志(LOG_EVERY_N)</a></li>
        <li><a href="#116-打印前-n-条日志log_first_n">11.6 打印前 N 条日志(LOG_FIRST_N)</a></li>
        <li><a href="#117-check-加强版的-assert">11.7 CHECK: 加强版的 assert</a></li>
        <li><a href="#118-配置项">11.8 配置项</a></li>
        <li><a href="#119-功能及性能测试">11.9 功能及性能测试</a></li>
      </ul>
    </li>
    <li><a href="#12-单元测试框架unitest">12. 单元测试框架(unitest)</a>
      <ul>
        <li><a href="#121-定义测试单元及用例">12.1 定义测试单元及用例</a></li>
        <li><a href="#122-运行测试用例">12.2 运行测试用例</a></li>
      </ul>
    </li>
    <li><a href="#13-高效-json-库json">13. 高效 json 库(json)</a>
      <ul>
        <li><a href="#131-基本类型">13.1 基本类型</a></li>
        <li><a href="#132-array-类型">13.2 array 类型</a></li>
        <li><a href="#133-object-类型">13.3 object 类型</a></li>
        <li><a href="#134-json-转字符串">13.4 json 转字符串</a></li>
        <li><a href="#135-字符串转-json">13.5 字符串转 json</a></li>
        <li><a href="#136-object-类型如何高效添加与查找成员">13.6 object 类型如何高效添加与查找成员</a></li>
        <li><a href="#137-字符串类型中的特殊字符">13.7 字符串类型中的特殊字符</a></li>
      </ul>
    </li>
    <li><a href="#14-时间库time">14. 时间库(time)</a>
      <ul>
        <li><a href="#141-monotonic-time">14.1 monotonic time</a></li>
        <li><a href="#142-时间字符串nowstr">14.2 时间字符串(now::str())</a></li>
        <li><a href="#143-sleep">14.3 sleep</a></li>
        <li><a href="#144-计时器timer">14.4 计时器(Timer)</a></li>
      </ul>
    </li>
    <li><a href="#15-线程库thread">15. 线程库(thread)</a>
      <ul>
        <li><a href="#151-互斥锁mutex">15.1 互斥锁(Mutex)</a></li>
        <li><a href="#152-同步事件syncevent">15.2 同步事件(SyncEvent)</a></li>
        <li><a href="#153-线程thread">15.3 线程(Thread)</a></li>
        <li><a href="#154-获取当前线程的-id">15.4 获取当前线程的 id</a></li>
        <li><a href="#155-基于-tls-的-thread_ptr">15.5 基于 TLS 的 thread_ptr</a></li>
        <li><a href="#156-定时任务调度器tasksched">15.6 定时任务调度器(TaskSched)</a></li>
      </ul>
    </li>
    <li><a href="#16-协程库co">16. 协程库(co)</a>
      <ul>
        <li><a href="#161-基本概念">16.1 基本概念</a></li>
        <li><a href="#162-创建协程go">16.2 创建协程(go)</a></li>
        <li><a href="#163-协程-api">16.3 协程 api</a></li>
        <li><a href="#164-网络编程">16.4 网络编程</a></li>
        <li><a href="#165-协程的同步机制">16.5 协程的同步机制</a></li>
        <li><a href="#166-协程池">16.6 协程池</a></li>
        <li><a href="#167-配置项">16.7 配置项</a></li>
      </ul>
    </li>
    <li><a href="#17-网络库so">17. 网络库(so)</a>
      <ul>
        <li><a href="#171-tcp-编程">17.1 TCP 编程</a></li>
        <li><a href="#172-http-编程">17.2 HTTP 编程</a></li>
        <li><a href="#173-rpc-框架">17.3 rpc 框架</a></li>
      </ul>
    </li>
    <li><a href="#18-hash-库hash">18. hash 库(hash)</a></li>
    <li><a href="#19-path-库path">19. path 库(path)</a></li>
    <li><a href="#20-文件系统操作fs">20. 文件系统操作(fs)</a>
      <ul>
        <li><a href="#201-元数据操作">20.1 元数据操作</a></li>
        <li><a href="#202-文件的基本读写操作">20.2 文件的基本读写操作</a></li>
        <li><a href="#203-文件流fsfstream">20.3 文件流(fs::fstream)</a></li>
      </ul>
    </li>
    <li><a href="#21-系统操作os">21. 系统操作(os)</a></li>
    <li><a href="#22-编译">22. 编译</a>
      <ul>
        <li><a href="#xmake">xmake</a></li>
        <li><a href="#cmake">cmake</a></li>
      </ul>
    </li>
    <li><a href="#23-结束语">23. 结束语</a></li>
  </ul>
</nav> 
</div>


<p><a href="https://github.com/idealvin/co/">CO</a> 是一个优雅、高效的 C++ 基础库，支持 Linux, Windows 与 Mac 平台。本文档将介绍 CO 的功能组件及使用方法。</p>
<h2 id="1-概览">1. 概览</h2>
<p>CO 追求极简、高效，不依赖于 <a href="https://www.boost.org/">boost</a> 等三方库，仅使用了少量的 C++11 特性。</p>
<ul>
<li>CO 包含的功能组件：
<ul>
<li>基本定义(def)</li>
<li>原子操作(atomic)</li>
<li>随机数生成器(random)</li>
<li>LruMap</li>
<li>基本类型快速转字符串(fast)</li>
<li>高效字符流(fastream)</li>
<li>高效字符串(fastring)</li>
<li>字符串操作(str)</li>
<li>命令行参数与配置文件解析库(flag)</li>
<li>高效流式日志库(log)</li>
<li>单元测试框架(unitest)</li>
<li>高效 json 库(json)</li>
<li>时间库(time)</li>
<li>线程库(thread)</li>
<li>协程库(co)</li>
<li>网络库(so)</li>
<li>hash 库(hash)</li>
<li>path 库(path)</li>
<li>文件系统操作(fs)</li>
<li>系统操作(os)</li>
</ul>
</li>
</ul>
<h2 id="2-基本定义def">2. 基本定义(def)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/def.h">co/def.h</a>.</p>
<h3 id="21-定长整数类型">2.1 定长整数类型</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"> int8   int16   int32   int64
uint8  uint16  uint32  uint64
</code></pre></div><p>这些类型在不同平台的长度是一致的，不存在可移植性问题。<a href="https://google.github.io/styleguide/cppguide.html#Integer_Types">Google Code Style</a> 建议除了 int，不要使用 short, long, long long 等内置整数类型。</p>
<p><code>def.h</code> 还定义了上述整数类型的最大、最小值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">MAX_UINT8  MAX_UINT16  MAX_UINT32  MAX_UINT64
MAX_INT8   MAX_INT16   MAX_INT32   MAX_INT64
MIN_INT8   MIN_INT16   MIN_INT32   MIN_INT64
</code></pre></div><h3 id="22-读写-1248-字节">2.2 读写 1、2、4、8 字节</h3>
<p><code>def.h</code> 定义了如下的宏，用于读写 1、2、4、8 字节的数据(注意边界对齐)：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">load8  load16  load32  load64
save8  save16  save32  save64
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">uint64 v;                  <span style="color:#75715e">// 8 字节
</span><span style="color:#75715e"></span>save32(<span style="color:#f92672">&amp;</span>v, <span style="color:#ae81ff">7</span>);             <span style="color:#75715e">// v 的前 4 个字节设为 7
</span><span style="color:#75715e"></span>uint16 x <span style="color:#f92672">=</span> load16(<span style="color:#f92672">&amp;</span>v);     <span style="color:#75715e">// 读取 v 的前 2 个字节
</span></code></pre></div><h3 id="23-disallow_copy_and_assign">2.3 DISALLOW_COPY_AND_ASSIGN</h3>
<p>这个宏用于禁止 C++ 类中的拷贝构造函数与赋值操作：</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    T();
    DISALLOW_COPY_AND_ASSIGN(T);
};
</code></pre></div><h3 id="24-force_cast-强制类型转换">2.4 force_cast 强制类型转换</h3>
<p><code>force_cast</code> 是对 C 风格强制类型转换的包装：</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> force_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">97</span>); <span style="color:#75715e">// char c = (char) 97;
</span></code></pre></div><h3 id="25-__forceinline-与-__thread">2.5 __forceinline 与 __thread</h3>
<p><a href="https://docs.microsoft.com/en-us/cpp/cpp/inline-functions-cpp?view=vs-2019#inline-__inline-and-__forceinline">__forceinline</a> 是 VS 中的关键字，Linux 等平台用下面的宏模拟：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define __forceinline __attribute__((always_inline))
</span></code></pre></div><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.4/gcc/Thread-Local.html">__thread</a> 是 gcc 中的关键字，用于支持 <a href="https://wiki.osdev.org/Thread_Local_Storage">TLS</a>，Windows 上用下面的宏模拟：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define __thread __declspec(thread)
</span></code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 获取当前线程的 id
</span><span style="color:#75715e"></span><span style="color:#66d9ef">__forceinline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gettid</span>() {
    <span style="color:#66d9ef">static</span> __thread <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> (id <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> id;
    <span style="color:#66d9ef">return</span> id <span style="color:#f92672">=</span> __gettid();
}
</code></pre></div><h3 id="26-unlikely">2.6 unlikely</h3>
<p><code>unlikely</code> 宏用于分支选择优化(仅支持 gcc、clang)：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 与 if (v == -1) 逻辑上等价，但提示编译器 v == -1 的可能性较小
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (unlikey(v <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) {
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;v == -1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h2 id="3-原子操作atomic">3. 原子操作(atomic)</h2>
<p>include: <a href="https://github.com/idealvin/co/tree/master/include/co/atomic.h">co/atomic.h</a>.</p>
<p><code>atomic</code> 库定义了如下的原子操作：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">atomic_inc        atomic_dec        atomic_add        atomic_sub
atomic_fetch_inc  atomic_fetch_dec  atomic_fetch_add  atomic_fetch_sub

atomic_or         atomic_and        atomic_xor
atomic_fetch_or   atomic_fetch_and  atomic_fetch_xor

atomic_swap    atomic_compare_swap
atomic_get     atomic_set    atomic_reset
</code></pre></div><p>上述原子操作适用于 1，2，4，8 字节长度的数据类型。inc，dec，add，sub，or，and，xor 各有一个 <code>fetch</code> 版，区别在于，fetch 版本返回原子操作之前的值，非 fetch 版本返回原子操作之后的值。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> b <span style="color:#f92672">=</span> false;
<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
uint64 u <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

atomic_inc(<span style="color:#f92672">&amp;</span>i);                 <span style="color:#75715e">// return ++i;
</span><span style="color:#75715e"></span>atomic_dec(<span style="color:#f92672">&amp;</span>i);                 <span style="color:#75715e">// return --i;
</span><span style="color:#75715e"></span>atomic_add(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">3</span>);              <span style="color:#75715e">// return i += 3;
</span><span style="color:#75715e"></span>atomic_sub(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">3</span>);              <span style="color:#75715e">// return i -= 3;
</span><span style="color:#75715e"></span>atomic_fetch_inc(<span style="color:#f92672">&amp;</span>u);           <span style="color:#75715e">// return u++;
</span><span style="color:#75715e"></span>
atomic_or(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">8</span>);               <span style="color:#75715e">// return i |= 8;
</span><span style="color:#75715e"></span>atomic_and(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">7</span>);              <span style="color:#75715e">// return i &amp;= 7;
</span><span style="color:#75715e"></span>atomic_xor(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">7</span>);              <span style="color:#75715e">// return i ^= 7;
</span><span style="color:#75715e"></span>atomic_fetch_xor(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">7</span>);        <span style="color:#75715e">// v = i; i ^= 7; return v;
</span><span style="color:#75715e"></span>
atomic_swap(<span style="color:#f92672">&amp;</span>b, true);          <span style="color:#75715e">// v = b; b = true; return v;    
</span><span style="color:#75715e"></span>atomic_compare_swap(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// v = i; if (i == 0) i = 1; return v;
</span><span style="color:#75715e"></span>
atomic_get(<span style="color:#f92672">&amp;</span>u);                 <span style="color:#75715e">// return u;
</span><span style="color:#75715e"></span>atomic_set(<span style="color:#f92672">&amp;</span>u, <span style="color:#ae81ff">7</span>);              <span style="color:#75715e">// u = 7;
</span><span style="color:#75715e"></span>atomic_reset(<span style="color:#f92672">&amp;</span>i);               <span style="color:#75715e">// i = 0;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// atomic operations on pointers
</span><span style="color:#75715e"></span>atomic_set(<span style="color:#f92672">&amp;</span>p, <span style="color:#ae81ff">0</span>);
atomic_swap(<span style="color:#f92672">&amp;</span>p, <span style="color:#ae81ff">8</span>);
atomic_compare_swap(<span style="color:#f92672">&amp;</span>p, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>);
</code></pre></div><h2 id="4-随机数生成器random">4. 随机数生成器(random)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/random.h">co/random.h</a>.</p>
<p><code>Random</code> 是一个速度极快的伪随机数生成器，可以连续无重复的生成 1 ~ 2G-2 之间的整数。<a href="https://github.com/google/leveldb/blob/master/util/random.h">leveldb</a> 用到了这种算法，本库选用了与 leveldb 不同的常数 <code>16385</code>，计算速度更快。算法的数学原理可以参考<a href="https://idealvin.github.io/coding/2018/08/random/">一种快速的随机数生成算法</a>一文。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Random <span style="color:#a6e22e">r</span>(<span style="color:#ae81ff">7</span>);      <span style="color:#75715e">// 7 是种子数，不带参数时，默认为 1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> r.next(); <span style="color:#75715e">// !! 非线程安全
</span></code></pre></div><h2 id="5-lrumap">5. LruMap</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/lru_map.h">co/lru_map.h</a>.</p>
<p>LRU 是一种常用的缓存策略，当缓存达到容量上限时，优先替换掉最近最少使用的数据。<code>LruMap</code> 基于 std::list、std::unordered_map 实现，内部元素是无序的。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LruMap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m(<span style="color:#ae81ff">128</span>);         <span style="color:#75715e">// capacity: 128
</span><span style="color:#75715e"></span>m.insert(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">23</span>);                 <span style="color:#75715e">// m.size() &gt; 128 时，删除内部 list 尾部的元素(最近最少使用)
</span><span style="color:#75715e"></span>                                 <span style="color:#75715e">// !! key 已经存在时，则不会插入新元素
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> m.find(<span style="color:#ae81ff">1</span>);             <span style="color:#75715e">// 找到时，将 1 放到内部 list 首部
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> m.end()) m.erase(it);  <span style="color:#75715e">// erase by iterator
</span><span style="color:#75715e"></span>m.erase(it<span style="color:#f92672">-&gt;</span>first);              <span style="color:#75715e">// erase by key
</span></code></pre></div><h2 id="6-基本类型快速转字符串fast">6. 基本类型快速转字符串(fast)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fast.h">co/fast.h</a>.</p>
<p><code>fast</code> 库提供了如下的函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">u32toh  u64toh  u32toa  u64toa  i32toa  i64toa  dtoa
</code></pre></div><p><code>xtoh</code> 系列函数将整数类型转换为十六进制字符串，内部用一个 table 缓存前 256 个数对应的 16 进制字符串(2个字节)，不同平台测试结果比 snprintf 快 10~25 倍左右。</p>
<p><code>xtoa</code> 系列函数将整数类型转换为十进制 ascii 字符串，内部用一个 table 缓存前 10000 个数对应的 10 进制字符串(4个字节)，不同平台测试结果比 snprintf 快 10~25 倍左右。</p>
<p><code>dtoa</code> 采用了 <a href="https://github.com/miloyip">Milo Yip</a> 的实现，详情见 <a href="https://github.com/miloyip/dtoa-benchmark">miloyip/dtoa-benchmark</a>。早期基于 <code>LruMap</code> 的实现，已弃用。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">32</span>];
<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> fast<span style="color:#f92672">::</span>u32toh(<span style="color:#ae81ff">255</span>, buf); <span style="color:#75715e">// &#34;0xff&#34;，返回长度 4
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> fast<span style="color:#f92672">::</span>i32toa(<span style="color:#f92672">-</span><span style="color:#ae81ff">99</span>, buf); <span style="color:#75715e">// &#34;-99&#34;, 返回长度 3
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> fast<span style="color:#f92672">::</span>dtoa(<span style="color:#ae81ff">0.123</span>, buf); <span style="color:#75715e">// &#34;0.123&#34;, 返回长度 5
</span></code></pre></div><p><code>fast</code> 库还提供一个 <code>fast::stream</code> 类，支持流式输出、append 等基本操作，是下述的 <code>fastream</code> 与 <code>fastring</code> 的基类。</p>
<h2 id="7-高效字符流fastream">7. 高效字符流(fastream)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fastream.h">co/fastream.h</a>.</p>
<p>C++ 标准库中的 <code>std::ostringstream</code> 性能较差，比 snprintf 慢好几倍。<code>fastream</code> 继承自 <code>fast::stream</code> 类，支持流式输出与二进制 append 操作。其中流式输出，在不同平台比 snprintf 快 10~30 倍左右。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fastream <span style="color:#a6e22e">fs</span>(<span style="color:#ae81ff">1024</span>);          <span style="color:#75715e">// 预分配 1k 内存
</span><span style="color:#75715e"></span>fs <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello world&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;  <span style="color:#75715e">// 流模式
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">23</span>;
<span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">8</span>];
fs.append(buf, <span style="color:#ae81ff">8</span>);      <span style="color:#75715e">// 追加 8 字节
</span><span style="color:#75715e"></span>fs.append(<span style="color:#f92672">&amp;</span>i, <span style="color:#ae81ff">4</span>);       <span style="color:#75715e">// 追加 4 字节
</span><span style="color:#75715e"></span>fs.append(i);           <span style="color:#75715e">// 追加 4 字节，与 fs.append(&amp;i, 4) 等价
</span><span style="color:#75715e"></span>fs.append((int16) <span style="color:#ae81ff">23</span>);  <span style="color:#75715e">// 追加 2 字节
</span><span style="color:#75715e"></span>fs.append(<span style="color:#e6db74">&#39;c&#39;</span>);         <span style="color:#75715e">// 追加单个字符
</span><span style="color:#75715e"></span>fs.append(<span style="color:#ae81ff">100</span>, <span style="color:#e6db74">&#39;c&#39;</span>);    <span style="color:#75715e">// 追加 100 个 &#39;c&#39;
</span><span style="color:#75715e"></span>fs.append(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#ae81ff">100</span>);    <span style="color:#75715e">// 追加 100 个 &#39;c&#39;
</span><span style="color:#75715e"></span>
fs.c_str();             <span style="color:#75715e">// 返回 C 风格字符串
</span><span style="color:#75715e"></span>fs.str();               <span style="color:#75715e">// 返回 C++ 字符串，内存拷贝
</span><span style="color:#75715e"></span>fs.data();              <span style="color:#75715e">// 返回数据指针
</span><span style="color:#75715e"></span>fs.size();              <span style="color:#75715e">// 返回数据长度
</span><span style="color:#75715e"></span>fs.capacity();          <span style="color:#75715e">// 容量
</span><span style="color:#75715e"></span>
fs.reserve(<span style="color:#ae81ff">4096</span>);       <span style="color:#75715e">// 预分配至少 4k 内存
</span><span style="color:#75715e"></span>fs.resize(<span style="color:#ae81ff">32</span>);          <span style="color:#75715e">// size -&gt; 32，buffer 中内容不变
</span><span style="color:#75715e"></span>fs.clear();             <span style="color:#75715e">// size -&gt; 0
</span><span style="color:#75715e"></span>fs.swap(fastream());    <span style="color:#75715e">// 交换
</span></code></pre></div><ul>
<li>注意事项</li>
</ul>
<p><code>fastream</code> 出于性能上的考虑，在 <code>append</code> 操作时不进行安全检查，如下面的代码是不安全的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fastream f;
f.append(<span style="color:#e6db74">&#34;hello&#34;</span>);
f.append(f.c_str() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 不安全，内部不考虑内存重叠的情况
</span></code></pre></div><h2 id="8-高效字符串fastring">8. 高效字符串(fastring)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fastring.h">co/fastring.h</a>.</p>
<p><code>fastring</code> 是 co 中的字符串类型，与 <code>fastream</code> 一样，继承于 <code>fast::stream</code>，因此除了基本的字符串操作，它同样也支持流式输出操作:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fastring s;
s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello world &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1234567</span>;
</code></pre></div><p>早期的 fastring 实现中使用了引用计数，导致 fastring 的复制行为与 <code>std::string</code> 不同，容易造成混淆。为了更好的取代 std::string，重构的版本中移除了引用计数。</p>
<p>fastring 几乎支持 fastream 的所有操作，但有一点与 fastream 不一样，fastring 在 <code>append</code> 时会进行安全检查:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fastring <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
fastream f;
f.append(<span style="color:#e6db74">&#34;hello&#34;</span>);

<span style="color:#75715e">// 复制的数据与自身数据重叠
</span><span style="color:#75715e"></span>s.append(s.c_str() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 安全，内部检测到内存重叠，进行特殊的处理
</span><span style="color:#75715e"></span>f.append(f.c_str() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 不安全，内部不检测内存重叠的情况，不能保证得到正确的结果
</span></code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fastring s;                <span style="color:#75715e">// 空字符串，无内存分配
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">s</span>(<span style="color:#ae81ff">32</span>);            <span style="color:#75715e">// 空字符串，预分配内存(容量为32)
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);       <span style="color:#75715e">// 非空字符串
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">s</span>(<span style="color:#ae81ff">88</span>, <span style="color:#e6db74">&#39;x&#39;</span>);       <span style="color:#75715e">// 初始化 s 为 88 个 &#39;x&#39;
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">s</span>(<span style="color:#e6db74">&#39;x&#39;</span>, <span style="color:#ae81ff">88</span>);       <span style="color:#75715e">// 初始化 s 为 88 个 &#39;x&#39;
</span><span style="color:#75715e"></span>fastring t <span style="color:#f92672">=</span> s;            <span style="color:#75715e">// 通过内存拷贝创建一个新的字符串
</span><span style="color:#75715e"></span>
s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;       <span style="color:#75715e">// 流式输出
</span><span style="color:#75715e"></span>s <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;xx&#34;</span>;                 <span style="color:#75715e">// 追加
</span><span style="color:#75715e"></span>s.append(<span style="color:#e6db74">&#34;xx&#34;</span>);            <span style="color:#75715e">// 追加  &lt;==&gt;  s += &#34;xx&#34;;
</span><span style="color:#75715e"></span>s.swap(fastring());        <span style="color:#75715e">// 交换
</span><span style="color:#75715e"></span>
s <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;xxx&#34;</span>;                 <span style="color:#75715e">// +
</span><span style="color:#75715e"></span>s <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#34;xxx&#34;</span>;                 <span style="color:#75715e">// &gt;
</span><span style="color:#75715e"></span>s <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#34;zzz&#34;</span>                  <span style="color:#75715e">// &lt;
</span><span style="color:#75715e"></span>s <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#34;zz&#34;</span>                  <span style="color:#75715e">// &lt;=
</span><span style="color:#75715e"></span>s <span style="color:#f92672">&gt;=</span> <span style="color:#e6db74">&#34;zz&#34;</span>                  <span style="color:#75715e">// &gt;=
</span><span style="color:#75715e"></span>
s.find(<span style="color:#e6db74">&#39;c&#39;</span>);               <span style="color:#75715e">// 查找字符
</span><span style="color:#75715e"></span>s.find(<span style="color:#e6db74">&#34;xx&#34;</span>, <span style="color:#ae81ff">3</span>);           <span style="color:#75715e">// 从 pos 3 开始查找子串
</span><span style="color:#75715e"></span>s.rfind(<span style="color:#e6db74">&#39;c&#39;</span>);              <span style="color:#75715e">// 反向查找字符
</span><span style="color:#75715e"></span>s.rfind(<span style="color:#e6db74">&#34;xx&#34;</span>);             <span style="color:#75715e">// 反向查找字符串
</span><span style="color:#75715e"></span>s.find_first_of(<span style="color:#e6db74">&#34;xy&#34;</span>);     <span style="color:#75715e">// 查找第一次出现的 &#34;xy&#34; 中的字符
</span><span style="color:#75715e"></span>s.find_first_not_of(<span style="color:#e6db74">&#34;xy&#34;</span>); <span style="color:#75715e">// 查找第一次出现的非 &#34;xy&#34; 中的字符
</span><span style="color:#75715e"></span>s.find_last_of(<span style="color:#e6db74">&#34;xy&#34;</span>);      <span style="color:#75715e">// 查找最后一次出现的 &#34;xy&#34; 中的字符
</span><span style="color:#75715e"></span>s.find_last_not_of(<span style="color:#e6db74">&#34;xy&#34;</span>);  <span style="color:#75715e">// 查找最后一次出现的非 &#34;xy&#34; 中的字符
</span><span style="color:#75715e"></span>
s.starts_with(<span style="color:#e6db74">&#39;x&#39;</span>);        <span style="color:#75715e">// s 是否以 &#39;x&#39; 开头
</span><span style="color:#75715e"></span>s.starts_with(<span style="color:#e6db74">&#34;xx&#34;</span>);       <span style="color:#75715e">// s 是否以 &#34;xx&#34; 开头
</span><span style="color:#75715e"></span>s.ends_with(<span style="color:#e6db74">&#39;x&#39;</span>);          <span style="color:#75715e">// s 是否以 &#39;x&#39; 结尾
</span><span style="color:#75715e"></span>s.ends_with(<span style="color:#e6db74">&#34;xx&#34;</span>);         <span style="color:#75715e">// s 是否以 &#34;xx&#34; 结尾
</span><span style="color:#75715e"></span>
s.replace(<span style="color:#e6db74">&#34;xxx&#34;</span>, <span style="color:#e6db74">&#34;yy&#34;</span>);    <span style="color:#75715e">// 将 s 中的 &#34;xxx&#34; 替换为 &#34;yy&#34;
</span><span style="color:#75715e"></span>s.replace(<span style="color:#e6db74">&#34;xxx&#34;</span>, <span style="color:#e6db74">&#34;yy&#34;</span>, <span style="color:#ae81ff">3</span>); <span style="color:#75715e">// 将 s 中的 &#34;xxx&#34; 替换为 &#34;yy&#34;，最多替换 3 次
</span><span style="color:#75715e"></span>
s.strip();                 <span style="color:#75715e">// 删除 s 两端的空白字符 &#34; \t\r\n&#34;
</span><span style="color:#75715e"></span>s.strip(<span style="color:#e6db74">&#34;ab&#34;</span>);             <span style="color:#75715e">// 删除 s 两端的 &#39;a&#39;, &#39;b&#39;
</span><span style="color:#75715e"></span>s.strip(<span style="color:#e6db74">&#34;ab&#34;</span>, <span style="color:#e6db74">&#39;l&#39;</span>);        <span style="color:#75715e">// 删除 s 左端的 &#39;a&#39;, &#39;b&#39;
</span><span style="color:#75715e"></span>s.strip(<span style="color:#e6db74">&#34;ab&#34;</span>, <span style="color:#e6db74">&#39;r&#39;</span>);        <span style="color:#75715e">// 删除 s 右端的 &#39;a&#39;, &#39;b&#39;
</span><span style="color:#75715e"></span>
s.tolower();               <span style="color:#75715e">// s 转换为小写
</span><span style="color:#75715e"></span>s.toupper();               <span style="color:#75715e">// s 转换为大写
</span><span style="color:#75715e"></span>s.lower();                 <span style="color:#75715e">// 返回 s 的小写形式，s 本身不变
</span><span style="color:#75715e"></span>s.upper();                 <span style="color:#75715e">// 返回 s 的大写形式，s 本身不变
</span><span style="color:#75715e"></span>s.match(<span style="color:#e6db74">&#34;x*y?z&#34;</span>);          <span style="color:#75715e">// 字符串匹配，* 匹配任意字符串，? 匹配单个字符
</span></code></pre></div><ul>
<li>注意事项</li>
</ul>
<p>fastring 中含有二进制字符时，不要使用 <code>find</code> 系列的操作:</p>
<ul>
<li>find()</li>
<li>rfind()</li>
<li>find_first_of()</li>
<li>find_first_not_of()</li>
<li>find_last_of()</li>
<li>find_last_not_of()</li>
</ul>
<p>上述方法基于 <code>strrchr</code>, <code>strstr</code>, <code>strcspn</code>, <code>strspn</code> 等实现，字符串中包含二进制字符时，不能保证得到正确的结果。</p>
<h2 id="9-字符串操作str">9. 字符串操作(str)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/str.h">co/str.h</a>.</p>
<h3 id="91-切分字符串split">9.1 切分字符串(split)</h3>
<p><code>split</code> 函数将字符串切分成若干个子串，原字符串保持不变，返回切分后的结果。</p>
<ul>
<li>函数原型</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// @s: 原字符串，fastring 或 const char*
</span><span style="color:#75715e">// @c: 分隔符，单个字符或&#39;\0&#39;结尾的字符串
</span><span style="color:#75715e">// @n: 切分次数，0 或 -1 表示不限次数，默认为 0
</span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fastring<span style="color:#f92672">&gt;</span> split(s, c, n<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">str<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;x y z&#34;</span>, <span style="color:#e6db74">&#39; &#39;</span>);     <span style="color:#75715e">// -&gt;  [ &#34;x&#34;, &#34;y&#34;, &#34;z&#34; ]
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;|x|y|&#34;</span>, <span style="color:#e6db74">&#39;|&#39;</span>);     <span style="color:#75715e">// -&gt;  [ &#34;&#34;, &#34;x&#34;, &#34;y&#34; ]
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;xooy&#34;</span>, <span style="color:#e6db74">&#34;oo&#34;</span>);     <span style="color:#75715e">// -&gt;  [ &#34;x&#34;, &#34;y&#34;]
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;xooy&#34;</span>, <span style="color:#e6db74">&#39;o&#39;</span>);      <span style="color:#75715e">// -&gt;  [ &#34;x&#34;, &#34;&#34;, &#34;y&#34; ]
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;xooy&#34;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#ae81ff">1</span>);   <span style="color:#75715e">// -&gt;  [ &#34;x&#34;, &#34;oy&#34; ]
</span></code></pre></div><h3 id="92-修剪字符串strip">9.2 修剪字符串(strip)</h3>
<p><code>strip</code> 函数去掉字符串左右两边指定的字符，原字符串保持不变，返回 strip 后的结果。</p>
<ul>
<li>函数原型</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// @s: 原字符串，fastring 或 const char*
</span><span style="color:#75715e">// @c: 需要去掉的字符集，单个字符或字符串
</span><span style="color:#75715e">// @d: 方向，&#39;l&#39; 或 &#39;L&#39; 修剪左边，&#39;r&#39; 或 &#39;R&#39; 修剪右边，默认为 &#39;b&#39;，修剪左右两边
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">strip</span>(s, c<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; </span><span style="color:#ae81ff">\t\r\n</span><span style="color:#e6db74">&#34;</span>, d<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;b&#39;</span>);
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">str<span style="color:#f92672">::</span>strip(<span style="color:#e6db74">&#34;abxxa&#34;</span>, <span style="color:#e6db74">&#34;ab&#34;</span>);       <span style="color:#75715e">// -&gt; &#34;xx&#34;    修剪两边
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>strip(<span style="color:#e6db74">&#34;abxxa&#34;</span>, <span style="color:#e6db74">&#34;ab&#34;</span>, <span style="color:#e6db74">&#39;l&#39;</span>);  <span style="color:#75715e">// -&gt; &#34;xxa&#34;   修剪左边
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>strip(<span style="color:#e6db74">&#34;abxxa&#34;</span>, <span style="color:#e6db74">&#34;ab&#34;</span>, <span style="color:#e6db74">&#39;r&#39;</span>);  <span style="color:#75715e">// -&gt; &#34;abxx&#34;  修剪右边
</span></code></pre></div><h3 id="93-替换子串replace">9.3 替换子串(replace)</h3>
<p><code>replace</code> 函数用于替换字符串中的子串，原字符串保持不变，返回替换后的结果。</p>
<ul>
<li>函数原型</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// @s:    原字符串，fastring 或 const char*
</span><span style="color:#75715e">// @sub:  替换前的子串
</span><span style="color:#75715e">// @to:   替换后的子串
</span><span style="color:#75715e">// @n:    最大替换次数，0 或 -1 表示不限制次数，默认为 0
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">replace</span>(s, sub, to, n<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">str<span style="color:#f92672">::</span>replace(<span style="color:#e6db74">&#34;xooxoox&#34;</span>, <span style="color:#e6db74">&#34;oo&#34;</span>, <span style="color:#e6db74">&#34;ee&#34;</span>);     <span style="color:#75715e">// -&gt; &#34;xeexeex&#34;
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>replace(<span style="color:#e6db74">&#34;xooxoox&#34;</span>, <span style="color:#e6db74">&#34;oo&#34;</span>, <span style="color:#e6db74">&#34;ee&#34;</span>, <span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// -&gt; &#34;xeexoox&#34;
</span></code></pre></div><h3 id="94-字符串转内置类型">9.4 字符串转内置类型</h3>
<p>str 库提供如下的函数，将字符串转为内置类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">to_int32  to_int64  to_uint32  to_uint64  to_bool  to_double
</code></pre></div><ul>
<li>
<p>函数说明</p>
<ul>
<li>若转换失败，抛出 const char* 类型的异常。</li>
<li>转换为整数时，字符串末尾可带单位 <code>k, m, g, t, p</code>，不区分大小写。</li>
</ul>
</li>
<li>
<p>代码示例</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> x <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>to_bool(<span style="color:#e6db74">&#34;false&#34;</span>);    <span style="color:#75715e">// &#34;true&#34; or &#34;1&#34; -&gt; true, &#34;false&#34; or &#34;0&#34; -&gt; false
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> x <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>to_double(<span style="color:#e6db74">&#34;3.14&#34;</span>); <span style="color:#75715e">// 3.14
</span><span style="color:#75715e"></span>
int32 x <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>to_int32(<span style="color:#e6db74">&#34;-23&#34;</span>);    <span style="color:#75715e">// -23 
</span><span style="color:#75715e"></span>int64 x <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>to_int64(<span style="color:#e6db74">&#34;4k&#34;</span>);     <span style="color:#75715e">// 4096
</span><span style="color:#75715e"></span>uint32 x <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>to_uint32(<span style="color:#e6db74">&#34;8M&#34;</span>);   <span style="color:#75715e">// 8 &lt;&lt; 20 
</span><span style="color:#75715e"></span>uint64 x <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>to_uint64(<span style="color:#e6db74">&#34;8T&#34;</span>);   <span style="color:#75715e">// 8ULL &lt;&lt; 40
</span></code></pre></div><h3 id="95-内置类型转字符串">9.5 内置类型转字符串</h3>
<p>str 库提供 <code>from</code> 函数，将内置类型转为字符串。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fastring s <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>from(true);  <span style="color:#75715e">// -&gt; &#34;true&#34;
</span><span style="color:#75715e"></span>fastring s <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>from(<span style="color:#ae81ff">23</span>);    <span style="color:#75715e">// -&gt; &#34;23&#34;
</span><span style="color:#75715e"></span>fastring s <span style="color:#f92672">=</span> str<span style="color:#f92672">::</span>from(<span style="color:#ae81ff">3.14</span>);  <span style="color:#75715e">// -&gt; &#34;3.14&#34;
</span></code></pre></div><h3 id="96-debug-string">9.6 debug string</h3>
<p>str 库提供 <code>dbg</code> 函数，从指定类型生成一个 debug 字符串。</p>
<ul>
<li>函数原型</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// @v: 内置类型，字符串类型，或常用的 STL 容器类型(vector, map, set)
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">dbg</span>(v);
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> };
std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m { {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>} };
str<span style="color:#f92672">::</span>dbg(v);    <span style="color:#75715e">// -&gt; &#34;[1,2,3]&#34;
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>dbg(s);    <span style="color:#75715e">// -&gt; &#34;{1,2,3}&#34;
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>dbg(m);    <span style="color:#75715e">// -&gt; &#34;{1:1,2:2}
</span><span style="color:#75715e"></span>
str<span style="color:#f92672">::</span>dbg(true); <span style="color:#75715e">// -&gt; &#34;true&#34;
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>dbg(<span style="color:#ae81ff">23</span>);   <span style="color:#75715e">// -&gt; &#34;23&#34;
</span><span style="color:#75715e"></span>str<span style="color:#f92672">::</span>dbg(<span style="color:#e6db74">&#34;23&#34;</span>); <span style="color:#75715e">// -&gt; &#34;\&#34;23\&#34;&#34;，字符串类型，两边加引号
</span></code></pre></div><ul>
<li>当字符串中含有 <code>&quot;</code> 时，dbg() 生成的字符串看起来会有点瑕疵，不过此函数一般用于打日志，应该无伤大雅。</li>
</ul>
<h2 id="10-命令行参数与配置文件解析库flag">10. 命令行参数与配置文件解析库(flag)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/flag.h">co/flag.h</a>.</p>
<h3 id="101-基本概念">10.1 基本概念</h3>
<p><code>flag</code> 库是一个类似 <a href="https://github.com/gflags/gflags">google gflags</a> 的命令行参数及配置文件解析库，其原理很简单，代码中定义静态全局变量，然后在程序启动时解析命令行参数及配置文件，修改这些全局变量的值。</p>
<h4 id="1011-flag-变量">10.1.1 flag 变量</h4>
<p>flag 库中的宏定义的静态全局变量，称为 <strong>flag 变量</strong>。如下面的代码定义了名为 <code>x</code> 的 flag 变量，它对应的全局变量名是 <code>FLG_x</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_bool(x, false, <span style="color:#e6db74">&#34;xxx&#34;</span>); <span style="color:#75715e">// bool FLG_x = false;
</span></code></pre></div><p>flag 库支持 7 种类型的 flag 变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span>, int32, int64, uint32, uint64, <span style="color:#66d9ef">double</span>, string
</code></pre></div><h4 id="1012-command-line-flag">10.1.2 command line flag</h4>
<p>命令行参数中，以 <code>-x=y</code> 的形式出现，其中 <code>x</code> 被称为一个 <code>command line flag</code>(以下都简称为 <code>flag</code>)。命令行中的 flag，与代码中的 flag 变量是一一对应的(下面不再区分二者)。flag 库为了简便易用，设计得非常灵活：</p>
<ul>
<li>-x=y 可以省略前面的 -，简写为 x=y.</li>
<li>-x=y 也可以写成 -x y.</li>
<li>x=y 前面可以带任意数量的 -.</li>
<li>bool 类型的 flag，-b=true 可以简写为 -b，简写时不能省略 -.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./exe -b -i<span style="color:#f92672">=</span><span style="color:#ae81ff">32</span> s<span style="color:#f92672">=</span>hello xx  <span style="color:#75715e"># b,i,s 是 flag，xx 不是 flag</span>
</code></pre></div><h3 id="102-flag-库的初始化">10.2 flag 库的初始化</h3>
<p>flag 库对外仅提供一个 api 函数 <code>flag::init()</code>，用于初始化 flag 库及解析命令行参数、配置文件等。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 主要流程:
</span><span style="color:#75715e">// 1. 扫描命令行参数，分成 flag 与非 flag 两类.
</span><span style="color:#75715e">// 2. 根据 flag 参数更新 FLG_config 的值，若非空，解析由此指定的配置文件.
</span><span style="color:#75715e">// 3. 根据 flag 参数更新 其他 flag 变量的值.
</span><span style="color:#75715e">// 4. 若 FLG_mkconf 非空，生成配置文件，退出程序.
</span><span style="color:#75715e">// 5. 若 FLG_daemon 为 true，将程序放入后台执行.
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 解析过程中遇到任何错误，输出错误信息，退出程序.
</span><span style="color:#75715e">// 解析全部正常，返回非 flag 的参数列表.
</span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>fastring<span style="color:#f92672">&gt;</span> init(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv);
</code></pre></div><p>此函数需要在进入 <code>main</code> 函数时调用一次：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/flag.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv) {
    flag<span style="color:#f92672">::</span>init(argc, argv);
}
</code></pre></div><h3 id="103-代码中定义声明及使用-flag-变量">10.3 代码中定义、声明及使用 flag 变量</h3>
<h4 id="1031-定义-flag-变量">10.3.1 定义 flag 变量</h4>
<p>flag 库提供了 7 个宏，分别用于定义 7 种不同类型的 flag 变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_bool  DEF_int32  DEF_int64  DEF_uint32  DEF_uint64  DEF_double  DEF_string
</code></pre></div><p>下面的代码，分别定义了类型为 bool 与 string 的两个 flag 变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_bool(b, false, <span style="color:#e6db74">&#34;comments&#34;</span>);  <span style="color:#75715e">// bool FLG_b = false;
</span><span style="color:#75715e"></span>DEF_string(s, <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;comments&#34;</span>);  <span style="color:#75715e">// fastring FLG_s = &#34;x&#34;;
</span></code></pre></div><p><code>DEF_xxx</code> 宏带有三个参数，第一个参数是 flag 变量名，第二个参数是默认值，第三个参数是注释。需要注意下面两点：</p>
<ul>
<li>flag 变量是全局变量，一般不要在头文件中定义它们。</li>
<li>flag 变量的名字是唯一的，不能定义两个名字相同的 flag 变量。</li>
</ul>
<h4 id="1032-声明-flag-变量">10.3.2 声明 flag 变量</h4>
<p>与定义类似，flag 库也提供了 7 个宏，分别用于声明 7 种不同类型的 flag 变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEC_bool  DEC_int32  DEC_int64  DEC_uint32  DEC_uint64  DEC_double  DEC_string
</code></pre></div><p>下面的代码声明了一个 int32 类型的变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEC_int32(i32); <span style="color:#75715e">// extern int32 FLG_i32;
</span></code></pre></div><p><code>DEC_xxx</code> 宏只有一个参数，接收 flag 变量名。一个 flag 变量只能定义一次，但可以声明多次，可以在任何需要的地方声明它们。声明一般用于引用其它地方定义的 flag 变量。</p>
<h4 id="1033-使用-flag-变量">10.3.3 使用 flag 变量</h4>
<p>定义或声明 flag 变量后，就可以像普通变量一样使用它们：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEC_bool(b);
<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>FLG_b) std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b is false&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;

DEF_string(s, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;xxx&#34;</span>);
FLG_s <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; world&#34;</span>;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> FLG_s <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</code></pre></div><h3 id="104-命令行中使用-flag">10.4 命令行中使用 flag</h3>
<h4 id="1041-命令行中设置-flag-变量的值">10.4.1 命令行中设置 flag 变量的值</h4>
<p>假设程序中定义了如下的 flag：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_bool(x, false, <span style="color:#e6db74">&#34;bool x&#34;</span>);
DEF_bool(y, false, <span style="color:#e6db74">&#34;bool y&#34;</span>);
DEF_int32(i, <span style="color:#f92672">-</span><span style="color:#ae81ff">32</span>, <span style="color:#e6db74">&#34;int32&#34;</span>);
DEF_uint64(u, <span style="color:#ae81ff">64</span>, <span style="color:#e6db74">&#34;uint64&#34;</span>);
DEF_double(d, <span style="color:#ae81ff">3.14</span>, <span style="color:#e6db74">&#34;double&#34;</span>);
DEF_string(s, <span style="color:#e6db74">&#34;hello world&#34;</span>, <span style="color:#e6db74">&#34;string&#34;</span>);
</code></pre></div><p>程序启动时，可以通过命令行参数修改 flag 变量的值：</p>
<ul>
<li>
<p><code>-x=y</code> 也可以写成 <code>-x y</code> 或者 <code>x=y</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./xx -i<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span> u<span style="color:#f92672">=</span><span style="color:#ae81ff">88</span> -s<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hello world&#34;</span>
./xx -i <span style="color:#ae81ff">8</span> -u <span style="color:#ae81ff">88</span> -s <span style="color:#e6db74">&#34;hello world&#34;</span>
</code></pre></div></li>
<li>
<p>bool flag 设置为 true 时，可以略去其值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./xx -x     <span style="color:#75715e"># -x=true</span>
</code></pre></div></li>
<li>
<p>多个单字母命名的 bool flag，可以合并设置为 true</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./xx -xy    <span style="color:#75715e"># -x=true -y=true</span>
</code></pre></div></li>
<li>
<p>整型 flag 可以带单位 <code>k, m, g, t, p</code>，不区分大小写</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./xx i<span style="color:#f92672">=</span>-4k  <span style="color:#75715e"># i=-4096</span>
</code></pre></div></li>
<li>
<p>整型 flag 可以传 8, 16 进制数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./xx i<span style="color:#f92672">=</span><span style="color:#ae81ff">032</span>  <span style="color:#75715e"># i=26     8 进制</span>
./xx u<span style="color:#f92672">=</span>0xff <span style="color:#75715e"># u=255   16 进制</span>
</code></pre></div></li>
</ul>
<h4 id="1042-查看帮助信息">10.4.2 查看帮助信息</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ ./xx --help
usage:
    ./xx --                   print flags info
    ./xx --help               print this help info
    ./xx --mkconf             generate config file
    ./xx --daemon             run as a daemon <span style="color:#f92672">(</span>Linux<span style="color:#f92672">)</span>
    ./xx xx.conf              run with config file
    ./xx config<span style="color:#f92672">=</span>xx.conf       run with config file
    ./xx -x -i<span style="color:#f92672">=</span>8k -s<span style="color:#f92672">=</span>ok       run with commandline flags
    ./xx -x -i 8k -s ok       run with commandline flags
    ./xx x<span style="color:#f92672">=</span>true i<span style="color:#f92672">=</span><span style="color:#ae81ff">8192</span> s<span style="color:#f92672">=</span>ok   run with commandline flags
</code></pre></div><h4 id="1043-查看-flag-变量列表">10.4.3 查看 flag 变量列表</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ ./xx --
--config: .path of config file
	 type: string	     default: <span style="color:#e6db74">&#34;&#34;</span>
	 from: ../../base/flag.cc
--mkconf: .generate config file
	 type: bool	     default: false
	 from: ../../base/flag.cc
</code></pre></div><h3 id="105-程序启动时指定配置文件">10.5 程序启动时指定配置文件</h3>
<p>命令行中可以用 flag <code>config</code> 指定程序的配置文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./xx config<span style="color:#f92672">=</span>xx.conf
./xx xx.conf     <span style="color:#75715e"># 若配置文件名以 .conf 或 config 结尾，且是程序命令行的第一个非 flag 参数，则可省略 config=</span>
./xx -x xx.conf  <span style="color:#75715e"># -x 是 flag，xx.conf 是第一个非 flag 参数</span>
</code></pre></div><p>另外也可以在代码中调用 <code>flag::init()</code> 之前，修改 <code>FLG_config</code> 的值，指定配置文件。</p>
<h3 id="106-自动生成配置文件">10.6 自动生成配置文件</h3>
<p>程序启动时，可以用 <code>--mkconf</code> 自动生成配置文件:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">./xx --mkconf          <span style="color:#75715e"># 在 xx 所在目录生成 xx.conf</span>
./xx --mkconf -x u<span style="color:#f92672">=</span><span style="color:#ae81ff">88</span>  <span style="color:#75715e"># 配置项可以用指定的值替代默认值</span>
</code></pre></div><p>配置项(flag) 按级别、所在文件名、所在代码行数进行排序。定义 flag 时可以在注释开头加上 <code>#n</code> 指定级别，<code>n</code> 必须是 0 到 99 之间的整数，不指定时默认为 10。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 指定 -daemon 级别为 0，级别小的排在前面
</span><span style="color:#75715e"></span>DEF_bool(daemon, false, <span style="color:#e6db74">&#34;#0 run program as a daemon&#34;</span>);
</code></pre></div><ul>
<li>特别说明
<ul>
<li>注释以<code>.</code>开头的 flag，带有<strong>隐藏</strong>属性，不会生成到配置文件中，但<code>./xx --</code>可以查看。</li>
<li>注释为空的 flag，带有<strong>隐身</strong>属性，不会生成到配置文件中，<code>./xx --</code>也无法查看。</li>
</ul>
</li>
</ul>
<h3 id="107-配置文件的格式">10.7 配置文件的格式</h3>
<p>flag 库的配置文件格式，也比较灵活：</p>
<ul>
<li>忽略行前、行尾的空白字符，书写更自由，不容易出错。</li>
<li><code>#</code> 或 <code>//</code> 表示注释，支持整行注释与行尾注释。</li>
<li>引号中的 <code>#</code> 或 <code>//</code> 不是注释。</li>
<li>一行一个 flag，形式强制统一为 x = y，看起来一目了然。</li>
<li><code>=</code> 号前后可以任意添加空白字符，书写更自由。</li>
<li>可以用 <code>\</code> 续行，以免一行太长，影响美观。</li>
<li>字符串不支持转义，以免产生歧义。</li>
</ul>
<p>下面是一个配置文件的示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">   <span style="color:#75715e"># config file: xx.conf</span>
     daemon <span style="color:#f92672">=</span> false            <span style="color:#75715e"># 后台运行程序 (daemon 由 flag 库内部定义)</span>
     boo <span style="color:#f92672">=</span> true                <span style="color:#75715e"># 不能像命令行中那样简写为 -boo</span>

     s <span style="color:#f92672">=</span>                       <span style="color:#75715e"># 空字符串</span>
     s <span style="color:#f92672">=</span> hello <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>         world                 <span style="color:#75715e"># s = &#34;helloworld&#34;</span>
     s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://github.com&#34;</span>   <span style="color:#75715e"># 引号中的 # 与 // 不是注释</span>
     s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;I&#39;m ok&#34;</span>              <span style="color:#75715e"># 字符串中含有单引号，两端可以加双引号</span>
     s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;how are &#34;U&#34;&#39;</span>         <span style="color:#75715e"># 字符串中含有双引号，两端可以加单引号</span>

     i32 <span style="color:#f92672">=</span> 4k                  <span style="color:#75715e"># 4096, 整型可以带单位 k,m,g,t,p，不区分大小写</span>
     i32 <span style="color:#f92672">=</span> <span style="color:#ae81ff">032</span>                 <span style="color:#75715e">#  8 进制，i32 = 26</span>
     i32 <span style="color:#f92672">=</span> 0xff                <span style="color:#75715e"># 16 进制，i32 = 255</span>
     pi <span style="color:#f92672">=</span> 3.14159              <span style="color:#75715e"># double 类型</span>
</code></pre></div><h2 id="11-高效流式日志库log">11. 高效流式日志库(log)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/log.h">co/log.h</a>.</p>
<h3 id="111-基本介绍">11.1 基本介绍</h3>
<p><code>log</code> 库是一个类似 <a href="https://github.com/google/glog">google glog</a> 的 C++ 流式日志库，打印日志比 printf 系列的函数更方便、更安全：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello world&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
</code></pre></div><p>log 库内部实现中采用异步方式，日志先写入缓存，达到一定量或超过一定时间后，由后台线程一并写入文件，性能在不同平台比 glog 提升了 20~150 倍左右。</p>
<p>下表是在不同平台连续打印 100 万条(每条 50 字节左右) info 级别日志的测试结果：</p>
<table>
<thead>
<tr>
<th>log vs glog</th>
<th>google glog</th>
<th>co/log</th>
</tr>
</thead>
<tbody>
<tr>
<td>win2012 HHD</td>
<td>1.6MB/s</td>
<td>180MB/s</td>
</tr>
<tr>
<td>win10 SSD</td>
<td>3.7MB/s</td>
<td>560MB/s</td>
</tr>
<tr>
<td>mac SSD</td>
<td>17MB/s</td>
<td>450MB/s</td>
</tr>
<tr>
<td>linux SSD</td>
<td>54MB/s</td>
<td>1023MB/s</td>
</tr>
</tbody>
</table>
<h3 id="112-api-介绍">11.2 Api 介绍</h3>
<p>log 库对外仅提供两个 api 函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>();
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">close</span>();
</code></pre></div><p><code>log::init()</code> 需要在 <code>main</code> 函数开头调用一次。由于 log 库依赖于 flag 库，所以 main 函数一般得像下面这样写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/flag.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/log.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv) {
    flag<span style="color:#f92672">::</span>init(argc, argv);
    log<span style="color:#f92672">::</span>init();
}
</code></pre></div><p><code>log::close()</code> 将缓存中的日志写入文件，并退出后台写日志的线程。log 库内部会捕获 <code>SIGINT, SIGTERM, SIGQUIT</code> 等信号，在程序退出前将缓存中的日志写入文件。</p>
<h3 id="113-打印不同级别的日志">11.3 打印不同级别的日志</h3>
<p>日志分为 debug, info, warning, error, fatal 5 个级别，可以分别用宏 DLOG, LOG, WLOG, ELOG, FLOG 打印 5 种不同级别的日志：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DLOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is DEBUG log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
LOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is INFO log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
WLOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is WARNING log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
ELOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is ERROR log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
FLOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is FATAL log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
</code></pre></div><p>打印 <code>fatal</code> 日志，表示程序出现了致命错误，log 库会打印当前线程的函数调用栈信息，并终止程序的运行。</p>
<h3 id="114-条件日志log_if">11.4 条件日志(LOG_IF)</h3>
<p>log 库也提供 <code>IF</code> 版的宏，接受一个条件参数，当满足指定条件时才打印日志。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DLOG_IF(cond) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is DEBUG log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
LOG_IF(cond) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is INFO log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
WLOG_IF(cond) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is WARNING log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
ELOG_IF(cond) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is ERROR log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
FLOG_IF(cond) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is FATAL log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
</code></pre></div><h3 id="115-每-n-条打印一次日志log_every_n">11.5 每 N 条打印一次日志(LOG_EVERY_N)</h3>
<p>log 库提供 <code>LOG_EVERY_N</code> 等宏，支持每 N 条打印一次日志，这些宏内部使用原子操作，保证线程安全性。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 打印第 1, 33, 65...... 条日志
</span><span style="color:#75715e"></span>DLOG_EVERY_N(<span style="color:#ae81ff">32</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is DEBUG log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
LOG_EVERY_N(<span style="color:#ae81ff">32</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is INFO log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
WLOG_EVERY_N(<span style="color:#ae81ff">32</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is WARNING log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
ELOG_EVERY_N(<span style="color:#ae81ff">32</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is ERROR log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
</code></pre></div><p>FLOG 没有这个功能，因为 FLOG 一打印，程序就挂了。</p>
<h3 id="116-打印前-n-条日志log_first_n">11.6 打印前 N 条日志(LOG_FIRST_N)</h3>
<p>log 库提供 <code>LOG_FIRST_N</code> 等宏，支持打印前 N 条日志。这些宏内部同样使用原子操作，保证线程安全性。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 打印前 10 条日志
</span><span style="color:#75715e"></span>DLOG_FIRST_N(<span style="color:#ae81ff">10</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is DEBUG log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
LOG_FIRST_N(<span style="color:#ae81ff">10</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is INFO log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
WLOG_FIRST_N(<span style="color:#ae81ff">10</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is WARNING log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
ELOG_FIRST_N(<span style="color:#ae81ff">10</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is ERROR log &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;
</code></pre></div><h3 id="117-check-加强版的-assert">11.7 CHECK: 加强版的 assert</h3>
<p>log 库提供了一系列的 CHECK 宏，可视为加强版的 assert，这些宏在 DEBUG 模式下也不会被清除。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">CHECK(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;say something here&#34;</span>;
CHECK_EQ(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);  <span style="color:#75715e">// ==
</span><span style="color:#75715e"></span>CHECK_NE(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);  <span style="color:#75715e">// !=
</span><span style="color:#75715e"></span>CHECK_GE(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);  <span style="color:#75715e">// &gt;=
</span><span style="color:#75715e"></span>CHECK_LE(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);  <span style="color:#75715e">// &lt;=
</span><span style="color:#75715e"></span>CHECK_GT(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);  <span style="color:#75715e">// &gt;  greater than
</span><span style="color:#75715e"></span>CHECK_LT(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);  <span style="color:#75715e">// &lt;  less than
</span></code></pre></div><p>CHECK 失败时，LOG 库会先调用 log::close() 写日志，再打印当前线程的函数调用栈信息，然后退出程序。</p>
<h3 id="118-配置项">11.8 配置项</h3>
<ul>
<li>
<p>log_dir</p>
<p>指定日志目录，默认为当前目录下的 <code>logs</code> 目录，不存在时将会自动创建。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_string(log_dir, <span style="color:#e6db74">&#34;logs&#34;</span>, <span style="color:#e6db74">&#34;Log dir, will be created if not exists&#34;</span>);
</code></pre></div></li>
<li>
<p>log_file_name</p>
<p>指定日志文件名(不含路径)，默认为空，使用程序名作为日志文件名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_string(log_file_name, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#e6db74">&#34;name of log file, using exename if empty&#34;</span>);
</code></pre></div></li>
<li>
<p>min_log_level</p>
<p>指定打印日志的最小级别，用于屏蔽低级别的日志，默认为 0，打印所有级别的日志。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_int32(min_log_level, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;write logs at or above this level, 0-4 (debug|info|warning|error|fatal)&#34;</span>);
</code></pre></div></li>
<li>
<p>max_log_file_size</p>
<p>指定日志文件的最大大小，默认 256M，超过此大小，生成新的日志文件，旧的日志文件会被重命名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_int64(max_log_file_size, <span style="color:#ae81ff">256</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#34;max size of log file, default: 256MB&#34;</span>);
</code></pre></div></li>
<li>
<p>max_log_file_num</p>
<p>指定日志文件的最大数量，默认是 8，超过此值，删除旧的日志文件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_uint32(max_log_file_num, <span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;max number of log files&#34;</span>);
</code></pre></div></li>
<li>
<p>max_log_buffer_size</p>
<p>指定日志缓存的最大大小，默认 32M，超过此值，丢掉一半的日志。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_uint32(max_log_buffer_size, <span style="color:#ae81ff">32</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#34;max size of log buffer, default: 32MB&#34;</span>);
</code></pre></div></li>
<li>
<p>cout</p>
<p>终端日志开关，默认为 false。若为 true，将日志也打印到终端。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DEF_bool(cout, false, <span style="color:#e6db74">&#34;also logging to terminal&#34;</span>);
</code></pre></div></li>
</ul>
<h3 id="119-功能及性能测试">11.9 功能及性能测试</h3>
<p>LOG 库的测试代码见 <a href="https://github.com/idealvin/co/blob/master/test/log_test.cc">test/log_test.cc</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 在 co 根目录执行下述命令</span>
xmake -b log    <span style="color:#75715e"># build log</span>

<span style="color:#75715e"># 打印不同类型的日志</span>
xmake r log

<span style="color:#75715e"># 日志也打印到终端</span>
xmake r log -cout

<span style="color:#75715e"># min_log_level 指定输出日志的最小级别</span>
xmake r log -min_log_level<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>   <span style="color:#75715e"># 0-4: debug,info,warning,error,fatal</span> 

<span style="color:#75715e"># 性能测试，单线程连续打印 100 万条 info 级别的日志</span>
xmake r log -perf
</code></pre></div><h2 id="12-单元测试框架unitest">12. 单元测试框架(unitest)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/unitest.h">co/unitest.h</a>.</p>
<p><code>unitest</code> 是一个单元测试框架，与 <a href="https://github.com/google/googletest">google gtest</a> 类似，但更简单易用。</p>
<h3 id="121-定义测试单元及用例">12.1 定义测试单元及用例</h3>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/unitest.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/os.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 定义一个名为 os 的测试单元，os 有 3 个不同的测试用例
</span><span style="color:#75715e">// 运行单元测试程序时，可用参数 -os 指定运行此单元测试中的用例
</span><span style="color:#75715e"></span>DEF_test(os) {
    DEF_case(homedir) {
        EXPECT_NE(os<span style="color:#f92672">::</span>homedir(), <span style="color:#e6db74">&#34;&#34;</span>);
    }

    DEF_case(pid) {
        EXPECT_GE(os<span style="color:#f92672">::</span>pid(), <span style="color:#ae81ff">0</span>);
    }

    DEF_case(cpunum) {
        EXPECT_GT(os<span style="color:#f92672">::</span>cpunum(), <span style="color:#ae81ff">0</span>);
    }
}
</code></pre></div><h3 id="122-运行测试用例">12.2 运行测试用例</h3>
<p><a href="https://github.com/idealvin/co/tree/master/unitest">co/unitest</a> 下有一些单元测试代码，可按下述步骤编译、执行：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 在 co 根目录执行下述命令</span>
xmake -b unitest    <span style="color:#75715e"># build unitest</span>

<span style="color:#75715e"># 运行所有测试用例</span>
xmake r unitest -a

<span style="color:#75715e"># 仅运行 os 单元中的测试用例</span>
xmake r unitest -os
</code></pre></div><h2 id="13-高效-json-库json">13. 高效 json 库(json)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/json.h">co/json.h</a>.</p>
<p><code>json</code> 库的设计原则是精简、高效、易用，其性能堪比 <a href="https://github.com/Tencent/rapidjson">rapidjson</a>，如果使用 <a href="https://github.com/jemalloc/jemalloc">jemalloc</a>，<code>parse</code> 与 <code>stringify</code> 的性能会进一步提升。</p>
<ul>
<li>json 库的特性
<ul>
<li>支持 null、bool、int、double、string 五种基本类型.</li>
<li>支持 array、object 两种复合类型.</li>
<li>所有类型统一用一个 <code>Json</code> 类表示.</li>
<li>Json 类内部仅一个指针数据成员，<code>sizeof(Json) == sizeof(void*)</code>.</li>
<li>Json 内置引用计数，复制操作仅增加引用计数(<strong>原子操作，线程安全</strong>)，不进行内存拷贝.</li>
<li>内置一个简单的内存分配器(Jalloc)，对大部分内存分配操作进行优化.</li>
</ul>
</li>
</ul>
<h3 id="131-基本类型">13.1 基本类型</h3>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Json x;                          <span style="color:#75715e">// null
</span><span style="color:#75715e"></span>x.is_null();                     <span style="color:#75715e">// 判断是否为 null
</span><span style="color:#75715e"></span>
Json x <span style="color:#f92672">=</span> false;                  <span style="color:#75715e">// bool 类型
</span><span style="color:#75715e"></span>x.is_bool();                     <span style="color:#75715e">// 判断是否为 bool 类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> b <span style="color:#f92672">=</span> x.get_bool();           <span style="color:#75715e">// 获取 bool 类型的值
</span><span style="color:#75715e"></span>
Json x <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;                    <span style="color:#75715e">// int 类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> x.get_int();             <span style="color:#75715e">// 获取 int 类型的值
</span><span style="color:#75715e"></span>
Json x <span style="color:#f92672">=</span> (int64) <span style="color:#ae81ff">23</span>;             <span style="color:#75715e">// int 类型，64位
</span><span style="color:#75715e"></span>int64 i <span style="color:#f92672">=</span> x.get_int64();         <span style="color:#75715e">// 返回 64 位整数
</span><span style="color:#75715e"></span>
Json x <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;                   <span style="color:#75715e">// double 类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> d <span style="color:#f92672">=</span> x.get_double();       <span style="color:#75715e">// 获取 double 类型的值
</span><span style="color:#75715e"></span>
Json x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span>;          <span style="color:#75715e">// 字符串类型
</span><span style="color:#75715e"></span>Json <span style="color:#a6e22e">x</span>(s, n);                    <span style="color:#75715e">// 字符串类型 (const char* s, size_t n)
</span><span style="color:#75715e"></span>x.is_string();                   <span style="color:#75715e">// 判断是否为字符串类型
</span><span style="color:#75715e"></span>x.size();                        <span style="color:#75715e">// 返回字符串的长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> s <span style="color:#f92672">=</span> x.get_string();  <span style="color:#75715e">// 返回字符串指针，字符串以 &#39;\0&#39; 结尾
</span></code></pre></div><h3 id="132-array-类型">13.2 array 类型</h3>
<p><code>array</code> 是一种数组类型，可以存储任意类型的 Json 对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Json x <span style="color:#f92672">=</span> json<span style="color:#f92672">::</span>array();      <span style="color:#75715e">// 创建空数组，不同于 null
</span><span style="color:#75715e"></span>x.is_array();                <span style="color:#75715e">// 判断是否为 array 类型
</span><span style="color:#75715e"></span>x.size();                    <span style="color:#75715e">// 返回 array 中元素个数
</span><span style="color:#75715e"></span>x.empty();                   <span style="color:#75715e">// 判断 array 是否为空
</span><span style="color:#75715e"></span>
Json x;                      <span style="color:#75715e">// null，调用 push_back 后自动变成 array 类型
</span><span style="color:#75715e"></span>x.push_back(false);          <span style="color:#75715e">// 添加 bool 类型的值
</span><span style="color:#75715e"></span>x.push_back(<span style="color:#ae81ff">1</span>);              <span style="color:#75715e">// 添加 int 类型的值
</span><span style="color:#75715e"></span>x.push_back(<span style="color:#ae81ff">3.14</span>);           <span style="color:#75715e">// 添加 double 类型的值
</span><span style="color:#75715e"></span>x.push_back(<span style="color:#e6db74">&#34;hello&#34;</span>);        <span style="color:#75715e">// 添加 string 类型的值
</span><span style="color:#75715e"></span>x.push_back(x);              <span style="color:#75715e">// 添加 array 类型的对象
</span><span style="color:#75715e"></span>x.push_back(obj);            <span style="color:#75715e">// 添加 object 类型的对象
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 访问 array 成员
</span><span style="color:#75715e"></span>x[<span style="color:#ae81ff">0</span>].get_bool();
x[<span style="color:#ae81ff">1</span>].get_int();

<span style="color:#75715e">// 遍历 array
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (uint32 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> x.size(); <span style="color:#f92672">++</span>i) {
    Json<span style="color:#f92672">&amp;</span> v <span style="color:#f92672">=</span> x[i];
}
</code></pre></div><h3 id="133-object-类型">13.3 object 类型</h3>
<p><code>object</code> 类型内部以 key-value 形式存储，value 可以是任意类型的 Json 对象，key 则有下面几条限制：</p>
<ul>
<li>key 必须是 <code>'\0'</code> 结尾的 C 字符串.</li>
<li>key 中不能包含双引号 <code>&quot;</code>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Json x <span style="color:#f92672">=</span> json<span style="color:#f92672">::</span>object();       <span style="color:#75715e">// 创建空 object 对象，不同于 null
</span><span style="color:#75715e"></span>x.is_object();                 <span style="color:#75715e">// 判断是否为 object 类型
</span><span style="color:#75715e"></span>x.size();                      <span style="color:#75715e">// 返回 object 中元素个数
</span><span style="color:#75715e"></span>x.empty();                     <span style="color:#75715e">// 判断 object 是否为空
</span><span style="color:#75715e"></span>
Json x;                        <span style="color:#75715e">// null, 调用 add_member() 后自动变成 object 类型
</span><span style="color:#75715e"></span>x.add_member(<span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;Bob&#34;</span>);   <span style="color:#75715e">// 添加字符串对象
</span><span style="color:#75715e"></span>x.add_member(<span style="color:#e6db74">&#34;age&#34;</span>, <span style="color:#ae81ff">23</span>);       <span style="color:#75715e">// 添加整数类型
</span><span style="color:#75715e"></span>x.add_member(<span style="color:#e6db74">&#34;height&#34;</span>, <span style="color:#ae81ff">1.68</span>);  <span style="color:#75715e">// 添加 double 类型
</span><span style="color:#75715e"></span>x.add_member(<span style="color:#e6db74">&#34;array&#34;</span>, array);  <span style="color:#75715e">// 添加 array 类型
</span><span style="color:#75715e"></span>x.add_member(<span style="color:#e6db74">&#34;obj&#34;</span>, obj);      <span style="color:#75715e">// 添加 object 类型
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// has_member 与 [] 各需查找一次
</span><span style="color:#75715e"></span>x.has_member(<span style="color:#e6db74">&#34;name&#34;</span>);          <span style="color:#75715e">// 判断是否包含成员 &#34;name&#34;
</span><span style="color:#75715e"></span>x[<span style="color:#e6db74">&#34;name&#34;</span>].get_string();        <span style="color:#75715e">// 获取成员的值
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// key 不存在时返回 null
</span><span style="color:#75715e"></span>Json v <span style="color:#f92672">=</span> x.find(<span style="color:#e6db74">&#34;age&#34;</span>);        <span style="color:#75715e">// Json 内置引用计数，返回对象不会影响性能.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (v.is_int()) v.get_int();

<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(v <span style="color:#f92672">=</span> x.find(<span style="color:#e6db74">&#34;obj&#34;</span>)).is_null()) {
    do_something();
}

<span style="color:#75715e">// 遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> x.begin(); it <span style="color:#f92672">!=</span> x.end(); <span style="color:#f92672">++</span>it) {
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> key <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>key;  <span style="color:#75715e">// key
</span><span style="color:#75715e"></span>    Json<span style="color:#f92672">&amp;</span> v <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>value;        <span style="color:#75715e">// value
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="134-json-转字符串">13.4 json 转字符串</h3>
<p>Json 类提供 <code>str()</code> 与 <code>pretty()</code> 方法，将 Json 转化成字符串:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Json x;
fastring s <span style="color:#f92672">=</span> x.str();     <span style="color:#75715e">// 返回字符串
</span><span style="color:#75715e"></span>fastring s <span style="color:#f92672">=</span> x.pretty();  <span style="color:#75715e">// 返回 pretty 字符串
</span><span style="color:#75715e"></span>
fastream fs;
fs <span style="color:#f92672">&lt;&lt;</span> x;                  <span style="color:#75715e">// 与 fs &lt;&lt; x.str() 同，但效率更高
</span><span style="color:#75715e"></span>LOG <span style="color:#f92672">&lt;&lt;</span> x;                 <span style="color:#75715e">// 日志库基于 fastream 实现，可以直接打印 json 对象
</span></code></pre></div><p>另外 Json 类还提供一个 <code>dbg()</code> 方法，将 Json 转化成 debug 字符串，Json 内部较长的字符串类型可能被截断:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Json x;
fastring s <span style="color:#f92672">=</span> x.dbg();
LOG <span style="color:#f92672">&lt;&lt;</span> x; <span style="color:#75715e">// 实际上相当于 LOG &lt;&lt; x.dbg();
</span></code></pre></div><h3 id="135-字符串转-json">13.5 字符串转 json</h3>
<p><code>json::parse()</code> 或者 Json 类中的 <code>parse_from()</code> 方法可以将字符串转化成 Json 对象:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Json x;
fastring s <span style="color:#f92672">=</span> x.str();

<span style="color:#75715e">// parse 失败时，y 为 null
</span><span style="color:#75715e"></span>Json y <span style="color:#f92672">=</span> json<span style="color:#f92672">::</span>parse(s);
Json y <span style="color:#f92672">=</span> json<span style="color:#f92672">::</span>parse(s.data(), s.size());
y.parse_from(x.str());
</code></pre></div><h3 id="136-object-类型如何高效添加与查找成员">13.6 object 类型如何高效添加与查找成员</h3>
<p><code>object</code> 类型，内部用数组保存 key-value 对，这样可以保持成员添加时的顺序，但同时增加了查找成员的开销。<code>operator[]</code> 会进行查找操作，实际应用中应该尽量避免使用。</p>
<ul>
<li>添加成员时用 <code>add_member()</code> 取代 operator[]</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// add_member 不查找，直接将成员添加到尾部
</span><span style="color:#75715e"></span>x.add_member(<span style="color:#e6db74">&#34;age&#34;</span>, <span style="color:#ae81ff">23</span>);  <span style="color:#75715e">// 比 x[&#34;age&#34;] = 23 效率更高
</span></code></pre></div><ul>
<li>查找成员时用 <code>find</code> 取代 operator[]</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 传统的成员访问，3 次查找操作，效率低
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (x.has_member(<span style="color:#e6db74">&#34;age&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> x[<span style="color:#e6db74">&#34;age&#34;</span>].is_int()) {
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> x[<span style="color:#e6db74">&#34;age&#34;</span>].get_int();
}

<span style="color:#75715e">// 用 find 只需一次查找操作
</span><span style="color:#75715e"></span>Json v <span style="color:#f92672">=</span> x.find(<span style="color:#e6db74">&#34;age&#34;</span>);  
<span style="color:#66d9ef">if</span> (v.is_int()) {
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> v.get_int();
}
</code></pre></div><h3 id="137-字符串类型中的特殊字符">13.7 字符串类型中的特殊字符</h3>
<p>json 字符串内部以 &lsquo;\0&rsquo; 结尾，应该避免在字符串中包含二进制字符。</p>
<p>json 字符串支持包含 <code>&quot;</code> 与 <code>\</code>，也支持 <code>\r, \n, \t</code> 等转义字符。但包含这些特殊字符，会降低 <code>json::parse()</code> 的性能，实际应用中应该尽量少用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Json x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello</span><span style="color:#ae81ff">\r\n\t</span><span style="color:#e6db74">&#34;</span>;      <span style="color:#75715e">// ok, 字符串中包含转义字符
</span><span style="color:#75715e"></span>Json x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">world&#34;</span>;     <span style="color:#75715e">// ok, 字符串中包含 &#34;
</span><span style="color:#75715e"></span>Json x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">world&#34;</span>;     <span style="color:#75715e">// ok, 字符串中包含 \ 
</span></code></pre></div><h2 id="14-时间库time">14. 时间库(time)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/time.h">co/time.h</a>.</p>
<h3 id="141-monotonic-time">14.1 monotonic time</h3>
<p><code>monotonic time</code> 在多数平台实现为自系统启动开始的时间，一般用于计时，比系统时间稳定，不受系统时间的影响。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">int64 us <span style="color:#f92672">=</span> now<span style="color:#f92672">::</span>us(); <span style="color:#75715e">// 微秒
</span><span style="color:#75715e"></span>int64 ms <span style="color:#f92672">=</span> now<span style="color:#f92672">::</span>ms(); <span style="color:#75715e">// 毫秒
</span></code></pre></div><h3 id="142-时间字符串nowstr">14.2 时间字符串(now::str())</h3>
<p><code>now::str()</code> 基于 <code>strftime</code> 实现，以指定格式返回当前系统时间的字符串形式。</p>
<ul>
<li>函数原型</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// fm: 时间输出格式
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">str</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> fm<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%Y-%m-%d %H:%M:%S&#34;</span>);
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fastring s <span style="color:#f92672">=</span> now<span style="color:#f92672">::</span>str();     <span style="color:#75715e">// &#34;2018-08-08 08:08:08&#34;
</span><span style="color:#75715e"></span>fastring s <span style="color:#f92672">=</span> now<span style="color:#f92672">::</span>str(<span style="color:#e6db74">&#34;%Y&#34;</span>); <span style="color:#75715e">// &#34;2028&#34;
</span></code></pre></div><h3 id="143-sleep">14.3 sleep</h3>
<p>Linux 平台支持微秒级的 sleep，但 Windows 平台难以实现。因此，time 库中仅支持毫秒、秒级的 sleep。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">sleep<span style="color:#f92672">::</span>ms(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">// sleep for 10 milliseconds
</span><span style="color:#75715e"></span>sleep<span style="color:#f92672">::</span>sec(<span style="color:#ae81ff">1</span>); <span style="color:#75715e">// sleep for 1 second
</span></code></pre></div><h3 id="144-计时器timer">14.4 计时器(Timer)</h3>
<p><code>Timer</code> 基于 monotonic 时间实现，对象创建时，即开始计时。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Timer t;
sleep<span style="color:#f92672">::</span>ms(<span style="color:#ae81ff">10</span>);

int64 us <span style="color:#f92672">=</span> t.us(); <span style="color:#75715e">// 微秒
</span><span style="color:#75715e"></span>int64 ms <span style="color:#f92672">=</span> t.ms(); <span style="color:#75715e">// 毫秒
</span><span style="color:#75715e"></span>
t.restart();       <span style="color:#75715e">// 重新开始计时
</span></code></pre></div><h2 id="15-线程库thread">15. 线程库(thread)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/thread.h">co/thread.h</a>.</p>
<h3 id="151-互斥锁mutex">15.1 互斥锁(Mutex)</h3>
<p><code>Mutex</code> 是多线程编程中常用的一种互斥锁，同一时刻，只能有一个线程抢到锁，其他线程必须等待锁被释放。</p>
<p>还有一种读写锁，同一时刻，允许多个线程读，但最多只有一个线程写。在实际应用中，读写锁性能较差，本库因此移除了读写锁。</p>
<p>与 <code>Mutex</code> 相对应的，有一个 <code>MutexGuard</code> 类，用于互斥锁的自动获取、释放。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Mutex m;
m.lock();         <span style="color:#75715e">// 获取锁，若锁已被其他线程占用，则当前线程会阻塞
</span><span style="color:#75715e"></span>m.unlock();       <span style="color:#75715e">// 释放锁
</span><span style="color:#75715e"></span>m.try_lock();     <span style="color:#75715e">// 获取锁，若锁已被其他线程占用，返回 false, 当前线程不会阻塞
</span><span style="color:#75715e"></span>
MutexGuard <span style="color:#a6e22e">g</span>(m);  <span style="color:#75715e">// 构造函数中调用 m.lock() 获取锁，析构函数中调用 m.unlock() 释放锁
</span></code></pre></div><h3 id="152-同步事件syncevent">15.2 同步事件(SyncEvent)</h3>
<p><code>SyncEvent</code> 是多线程编程中常用的一种同步机制，适用于生产者-消费者模型。</p>
<ul>
<li>SyncEvent 构造函数说明</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// manual_reset: 是否在 wait 结束时手动设置 event 的同步状态
</span><span style="color:#75715e">// signaled:     event 的初始状态是否为 signaled
</span><span style="color:#75715e"></span>SyncEvent(<span style="color:#66d9ef">bool</span> manual_reset<span style="color:#f92672">=</span>false, <span style="color:#66d9ef">bool</span> signaled<span style="color:#f92672">=</span>false);
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">SyncEvent ev;
ev.wait();                 <span style="color:#75715e">// 线程 A，等待事件同步，wait() 函数自动将 event 状态设置为 unsignaled
</span><span style="color:#75715e"></span>ev.signal();               <span style="color:#75715e">// 线程 B，事件同步通知
</span><span style="color:#75715e"></span>
SyncEvent <span style="color:#a6e22e">ev</span>(true, false); <span style="color:#75715e">// 启用 manual_reset，等待的线程需要手动设置 event 同步状态
</span><span style="color:#75715e"></span>ev.wait(<span style="color:#ae81ff">1000</span>);             <span style="color:#75715e">// 线程 A，等待 1000 毫秒，直到事件同步或超时
</span><span style="color:#75715e"></span>ev.reset();                <span style="color:#75715e">// 线程 A，手动设置 event 状态为 unsignaled
</span><span style="color:#75715e"></span>ev.signal();               <span style="color:#75715e">// 线程 B，事件同步通知
</span></code></pre></div><h3 id="153-线程thread">15.3 线程(Thread)</h3>
<p><code>Thread</code> 类是对线程的封装，创建 Thread 对象时，线程就会启动，线程函数执行完时，线程自动退出。</p>
<p>Thread 类除构造、析构函数外，仅提供两个方法:</p>
<ul>
<li>
<p><code>join()</code>, 阻塞，等待线程函数执行完，然后退出线程</p>
</li>
<li>
<p><code>detach()</code>, 不阻塞，线程函数执行完时，自动释放系统资源</p>
</li>
<li>
<p>代码示例</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 启动线程
</span><span style="color:#75715e"></span>Thread <span style="color:#a6e22e">x</span>(f);                        <span style="color:#75715e">// void f();
</span><span style="color:#75715e"></span>Thread <span style="color:#a6e22e">x</span>(f, p);                     <span style="color:#75715e">// void f(void*);  void* p;
</span><span style="color:#75715e"></span>Thread <span style="color:#a6e22e">x</span>(<span style="color:#f92672">&amp;</span>T<span style="color:#f92672">::</span>f, <span style="color:#f92672">&amp;</span>t);                <span style="color:#75715e">// void T::f();  T t;
</span><span style="color:#75715e"></span>Thread <span style="color:#a6e22e">x</span>(std<span style="color:#f92672">::</span>bind(f, <span style="color:#ae81ff">7</span>));          <span style="color:#75715e">// void f(int v);
</span><span style="color:#75715e"></span>Thread <span style="color:#a6e22e">x</span>(std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>T<span style="color:#f92672">::</span>f, <span style="color:#f92672">&amp;</span>t, <span style="color:#ae81ff">7</span>));  <span style="color:#75715e">// void T::f(int v);  T t;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 阻塞，等线程函数执行完
</span><span style="color:#75715e"></span>x.join();                           

<span style="color:#75715e">// 启动线程，并销毁 Thread 对象，线程独立于 Thread 对象运行
</span><span style="color:#75715e"></span>Thread(f).detach();
</code></pre></div><h3 id="154-获取当前线程的-id">15.4 获取当前线程的 id</h3>
<p><code>current_thread_id()</code> 用于获取当前线程的 id，thread 库利用 <a href="https://wiki.osdev.org/Thread_Local_Storage">TLS</a> 保存线程 id，每个线程只需一次系统调用。</p>
<p>Linux glibc 从 <code>2.30</code> 版本开始增加了 gettid 系统调用，为避免冲突，thread 库移除了早期提供的 gettid 接口，改为 <code>current_thread_id</code>。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> current_thread_id();
</code></pre></div><h3 id="155-基于-tls-的-thread_ptr">15.5 基于 TLS 的 thread_ptr</h3>
<p><code>thread_ptr</code> 用法与 <code>std::unique_ptr</code> 类似，但内部使用了 <code>TLS</code> 机制，每个线程设置并拥有自己的 ptr。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">T</span> {
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
        cout <span style="color:#f92672">&lt;&lt;</span> current_thread_id() <span style="color:#f92672">&lt;&lt;</span> endl;
    }
};

thread_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> pt;

<span style="color:#75715e">// 在 thread 1 的线程函数中执行
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (pt <span style="color:#f92672">==</span> NULL) pt.reset(<span style="color:#66d9ef">new</span> T); 
pt<span style="color:#f92672">-&gt;</span>run();  <span style="color:#75715e">// 打印 thread 1 的 id
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 在 thread 2 的线程函数中执行
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (pt <span style="color:#f92672">==</span> NULL) pt.reset(<span style="color:#66d9ef">new</span> T);
pt<span style="color:#f92672">-&gt;</span>run();  <span style="color:#75715e">// 打印 thread 2 的 id
</span></code></pre></div><h3 id="156-定时任务调度器tasksched">15.6 定时任务调度器(TaskSched)</h3>
<p><code>TaskSched</code> 类用于定时任务的调度，内部由单线程调度所有任务，但可以从任意线程添加任务。</p>
<ul>
<li>TaskSched 提供的方法
<ul>
<li>run_in</li>
<li>run_every</li>
<li>run_daily</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// @f: std::function&lt;void()&gt; 类型的函数对象
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// n 秒后执行 f 一次
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run_in</span>(f, n);

<span style="color:#75715e">// 每 n 秒执行一次 f
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run_every</span>(f, n);

<span style="color:#75715e">// 每天的 hour:min:sec 执行一次
</span><span style="color:#75715e">// @hour: 0-23，默认为 0
</span><span style="color:#75715e">// @min:  0-59，默认为 0
</span><span style="color:#75715e">// @sec:  0-59，默认为 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run_daily</span>(f, hour<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, min<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, sec<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);
</code></pre></div><ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">TaskSched s;                      <span style="color:#75715e">// 启动任务调度线程
</span><span style="color:#75715e"></span>s.run_in(f, <span style="color:#ae81ff">3</span>);                   <span style="color:#75715e">// 3 秒后执行 f 一次    void f();
</span><span style="color:#75715e"></span>s.run_every(std<span style="color:#f92672">::</span>bind(f, <span style="color:#ae81ff">0</span>), <span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// 每 3 秒执行一次 f    void f(int);
</span><span style="color:#75715e"></span>s.run_daily(f);                   <span style="color:#75715e">// 每天 00:00:00 执行一次 f
</span><span style="color:#75715e"></span>s.run_daily(f, <span style="color:#ae81ff">23</span>);               <span style="color:#75715e">// 每天 23:00:00 执行一次 f
</span><span style="color:#75715e"></span>s.run_daily(f, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">30</span>);           <span style="color:#75715e">// 每天 23:30:00 执行一次 f
</span><span style="color:#75715e"></span>s.stop();                         <span style="color:#75715e">// 退出任务调度线程
</span></code></pre></div><h2 id="16-协程库co">16. 协程库(co)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/co.h">co/co.h</a>.</p>
<h3 id="161-基本概念">16.1 基本概念</h3>
<ul>
<li>协程是运行于线程中的轻量级调度单位.</li>
<li>协程之于线程，类似于线程之于进程.</li>
<li>一个进程中可以存在多个线程，一个线程中可以存在多个协程.</li>
<li>协程所在的线程一般被称为调度线程.</li>
<li>一个协程发生 io 阻塞或调用 sleep 等操作时，调度线程会挂起此协程.</li>
<li>一个协程挂起时，调度线程会切换到其他等待执行的协程运行.</li>
<li>协程的切换是在用户态进行的，比线程间的切换更快.</li>
</ul>
<p>协程非常适合写网络程序，可以实现同步的编程方式，不需要异步回调，大大减轻了程序员的思想负担。</p>
<p><code>co</code> 协程库实现的是一种 <a href="https://github.com/golang/go/">golang</a> 风格的协程，有下面几个特性:</p>
<ul>
<li>内置多个调度线程，默认为系统 CPU 核数.</li>
<li>同一调度线程中的协程共用一个栈，协程挂起时，会将栈上数据 copy 出来，切换回来时再将数据 copy 到栈上. 这种方式大大降低了内存占用，单机可以轻松创建上百万协程.</li>
<li>各协程之间为平级关系，可以在任何地方(包括在协程中)创建新的协程.</li>
</ul>
<p>co 协程库在 linux, mac, windows 等平台，分别基于 <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>, <a href="https://man.openbsd.org/kqueue.2">kqueue</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">iocp</a> 实现。</p>
<p>co 协程库中 context 切换的相关代码，取自 <a href="https://github.com/waruqi">ruki</a> 的 <a href="https://github.com/tboox/tbox/">tbox</a>，而 tbox 则参考了 <a href="https://www.boost.org/doc/libs/1_70_0/libs/context/doc/html/index.html">boost</a> 的实现，在此表示感谢！</p>
<h3 id="162-创建协程go">16.2 创建协程(go)</h3>
<p><code>golang</code> 中用关键字 <code>go</code> 创建协程，与之类似，co 库中提供 <code>go()</code> 方法创建协程。</p>
<p>创建协程与创建线程类似，需要指定一个协程函数，go() 方法的第一个参数就是协程函数:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">go</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>f)());
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">go</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>f)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>), <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p);  <span style="color:#75715e">// p 指定函数参数
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> go(<span style="color:#66d9ef">void</span> (T<span style="color:#f92672">::*</span>f)(), T<span style="color:#f92672">*</span> p);       <span style="color:#75715e">// p 绑定 T 类对象
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">go</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&amp;</span> f);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">go</span>(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&amp;&amp;</span> f);
</code></pre></div><p>实际测试发现，创建 <code>std::function</code> 类型的对象开销较大，因此 go() 特别对 <code>void f()</code>、<code>void f(void*)</code>、<code>void T::f()</code> 类型的函数进行了优化，实际应用中，应该优先使用这三类函数。</p>
<p>严格来说，go() 方法只是将 <code>callback</code> 分配到一个调度线程中，真正创建协程是由调度线程完成的。但从用户的角度看，逻辑上可以认为 go() 创建了协程，并分配到指定的调度线程中，等待被执行。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">go(f);                       <span style="color:#75715e">// void f();
</span><span style="color:#75715e"></span>go(f, p);                    <span style="color:#75715e">// void f(void*);   void* p;
</span><span style="color:#75715e"></span>go(<span style="color:#f92672">&amp;</span>T<span style="color:#f92672">::</span>f, p);                <span style="color:#75715e">// void T::f();     T* p;
</span><span style="color:#75715e"></span>go(std<span style="color:#f92672">::</span>bind(f, <span style="color:#ae81ff">7</span>));         <span style="color:#75715e">// void f(int);
</span><span style="color:#75715e"></span>go(std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>T<span style="color:#f92672">::</span>f, p, <span style="color:#ae81ff">7</span>));  <span style="color:#75715e">// void T::f(int);  T* p;
</span></code></pre></div><h3 id="163-协程-api">16.3 协程 api</h3>
<p>除 <code>go()</code> 之外，co 协程库还提供了如下的几个 api (位于 namespace co 中):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sleep</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ms);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stop</span>();
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">max_sched_num</span>();
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sched_id</span>();
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">coroutine_id</span>();
</code></pre></div><ul>
<li>
<p><code>sleep</code> 在协程中调用时，调度线程会挂起此协程，切换到其他等待执行的协程运行。</p>
</li>
<li>
<p><code>stop</code> 会退出所有的调度线程，一般在进程退出前调用。</p>
</li>
<li>
<p><code>max_sched_num</code> 返回支持的最大调度线程数，目前这个值是系统 cpu 核数。</p>
</li>
<li>
<p><code>sched_id</code> 返回当前调度线程的 id，若当前线程不是调度线程，返回 -1。id 取值范围是 0 到 <code>max_sched_num-1</code>。</p>
</li>
<li>
<p><code>coroutine_id</code> 返回当前协程的 id，若当前线程不是协程，返回 -1。不同调度线程中的协程可能拥有相同的 id。</p>
</li>
<li>
<p>代码示例</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 每隔 1 秒打印出当前的 sched_id 与 coroutine_id
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">while</span> (true) {
        co<span style="color:#f92672">::</span>sleep(<span style="color:#ae81ff">1000</span>);
        LOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;sid: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> co<span style="color:#f92672">::</span>sched_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; cid: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> co<span style="color:#f92672">::</span>coroutine_id();
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv) {
    flag<span style="color:#f92672">::</span>init(argc, argv);
    log<span style="color:#f92672">::</span>init();

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">32</span>; <span style="color:#f92672">++</span>i) go(f);

    sleep<span style="color:#f92672">::</span>sec(<span style="color:#ae81ff">8</span>);  <span style="color:#75715e">// 防止主线程立即退出
</span><span style="color:#75715e"></span>    co<span style="color:#f92672">::</span>stop();     <span style="color:#75715e">// 退出所有调度线程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="164-网络编程">16.4 网络编程</h3>
<p>co 包装了常用的 socket api，以支持一般的网络编程。这些 api 都在 <code>namespace co</code> 中，除了少数几个，一般必须在协程中调用。与原生 api 不同的是，这些 api 在 io 阻塞或调用 sleep 等操作时，调度线程会挂起当前协程，切换到其他等待执行的协程运行。</p>
<h4 id="1641-常用的-socket-api">16.4.1 常用的 socket api</h4>
<p>co 提供了一些常用的 socket api:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">sock_t <span style="color:#a6e22e">socket</span>(<span style="color:#66d9ef">int</span> domain, <span style="color:#66d9ef">int</span> type, <span style="color:#66d9ef">int</span> proto);
sock_t <span style="color:#a6e22e">tcp_socket</span>(<span style="color:#66d9ef">int</span> af<span style="color:#f92672">=</span>AF_INET); <span style="color:#75715e">// @af: address family, AF_INET, AF_INET6, etc.
</span><span style="color:#75715e"></span>sock_t <span style="color:#a6e22e">udp_socket</span>(<span style="color:#66d9ef">int</span> af<span style="color:#f92672">=</span>AF_INET); <span style="color:#75715e">// @af: address family, AF_INET, AF_INET6, etc.
</span><span style="color:#75715e"></span>
close  shutdown   bind   listen   accept   getsockopt
recv   recvfrom   send   sendto   connect  setsockopt

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">recvn</span>(sock_t fd, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> buf, <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> ms<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>);
</code></pre></div><p>co 提供的 api 大部分形式上与原生的 socket api 一致，用法也几乎一样，只是有些细微的差别，说明如下:</p>
<ul>
<li>
<p>原生 api 参数中的 <code>struct sockaddr*</code> 替换成了 <code>void*</code>，免去手动转换的麻烦。</p>
</li>
<li>
<p><code>socket</code>, <code>tcp_socket</code>, <code>udp_socket</code> 用于创建 socket，创建的 socket 在 linux/mac 平台是非阻塞的，在 windows 平台则是 <a href="https://support.microsoft.com/en-us/help/181611/socket-overlapped-i-o-versus-blocking-nonblocking-mode">overlapped</a> 的，无需用户另行设置。</p>
</li>
<li>
<p><code>close</code> 可以多带一个参数 <code>@ms</code>(默认为 0)，将当前协程挂起若干毫秒，再关闭 socket。</p>
</li>
<li>
<p><code>shutdown</code> 用单个字符 <code>@c</code> 指定关闭方向，<code>'r'</code> 关闭读，<code>'w'</code> 关闭写，默认关闭读写。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">shutdown</span>(sock_t fd, <span style="color:#66d9ef">char</span> c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;b&#39;</span>);
</code></pre></div><ul>
<li>
<p><code>accept</code> 返回的 socket 是非阻塞或 overlapped 的，无需用户另行设置。</p>
</li>
<li>
<p><code>connect, recv, recvn, recvfrom, send, sendto</code> 可以多带一个参数，指定超时时间 <code>@ms</code>(默认为 -1)。超时发生时，这些 api 返回 -1，并设置 errno 为 <code>ETIMEDOUT</code>。</p>
</li>
<li>
<p><code>recvn</code> 接收 <code>@n</code> 字节的 tcp 数据，全部接收完返回 n，连接断开返回 0，其他错误返回 -1。</p>
</li>
<li>
<p><strong>注意:</strong> accept, connect, recv, recvn, recvfrom, send 与 sendto 必须在协程中调用。</p>
</li>
<li>
<p><strong>特别注意:</strong> <code>close</code> 与 <code>shutdown</code> 虽然不会阻塞，但为了正常完成内部的清理工作，必须在协程所在的调度线程中调用。一般而言，在一个协程中进行 recv, send 等操作时，那么最好也在这个协程中调用 close, shutdown 关闭 socket。</p>
</li>
</ul>
<p>上述 api 发生错误时返回 -1，可以用 <code>co::error()</code> 获取错误码，<code>co::strerror()</code> 查看错误描述。</p>
<h4 id="1642-常用的-socket-option-设置">16.4.2 常用的 socket option 设置</h4>
<p>co 提供了下面的几个 api，用于设置常用的 socket 选项:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_reuseaddr</span>(sock_t fd);                <span style="color:#75715e">// 设置 SO_REUSEADDR
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_tcp_nodelay</span>(sock_t fd);              <span style="color:#75715e">// 设置 TCP_NODELAY 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_tcp_keepalive</span>(sock_t fd);            <span style="color:#75715e">// 设置 SO_KEEPALIVE
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_send_buffer_size</span>(sock_t fd, <span style="color:#66d9ef">int</span> n);  <span style="color:#75715e">// 设置发送缓冲区大小
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_recv_buffer_size</span>(sock_t fd, <span style="color:#66d9ef">int</span> n);  <span style="color:#75715e">// 设置接收缓冲区大小
</span></code></pre></div><h4 id="1643-其他-api">16.4.3 其他 api</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 填充 ip 地址
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">init_ip_addr</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span><span style="color:#f92672">*</span> addr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ip, <span style="color:#66d9ef">int</span> port);
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">init_ip_addr</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in6</span><span style="color:#f92672">*</span> addr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ip, <span style="color:#66d9ef">int</span> port);

<span style="color:#75715e">// ip 地址转换成字符串
</span><span style="color:#75715e"></span>fastring <span style="color:#a6e22e">ip_str</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span><span style="color:#f92672">*</span> addr);
fastring <span style="color:#a6e22e">ip_str</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in6</span><span style="color:#f92672">*</span> addr);

<span style="color:#75715e">// 发送一个 RST，非正常关闭 tcp 连接，避免进入 timedwait 状态，多用于服务端
</span><span style="color:#75715e">// @ms: 默认为 0，将当前协程挂起若干毫秒后，再发送 RST
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reset_tcp_socket</span>(sock_t fd, <span style="color:#66d9ef">int</span> ms<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">error</span>();                    <span style="color:#75715e">// 返回当前错误码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">strerror</span>();         <span style="color:#75715e">// 返回当前错误码对应的字符串
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">strerror</span>(<span style="color:#66d9ef">int</span> err);  <span style="color:#75715e">// 返回 @err 对应的字符串
</span></code></pre></div><h4 id="1644-hook-系统-api">16.4.4 hook 系统 api</h4>
<p>在协程中调用 co 库的 socket api 不会阻塞，但一些三方库中调用的是系统的 socket api，仍然可能阻塞。为了解决这个问题，需要 hook 系统的 api，迫使三方库调用 hook 后的 api。</p>
<p>co 库目前在 linux/mac 平台已支持 hook，下面是 hook 的函数列表:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">sleep   usleep   nanosleep

accept  accept4  connect   close  shutdown
read    readv    recv   recvfrom   recvmsg
write   writev   send   sendto     sendmsg
select  poll  gethostbyaddr  gethostbyname

gethostbyaddr_r  gethostbyname2   <span style="color:#75715e">// linux
</span><span style="color:#75715e"></span>gethostbyname_r  gethostbyname2_r <span style="color:#75715e">// linux
</span><span style="color:#75715e"></span>
epoll_wait  <span style="color:#75715e">// linux 
</span><span style="color:#75715e"></span>kevent      <span style="color:#75715e">// mac
</span></code></pre></div><p>用户一般不需要关心 api hook，有兴趣可以查看 <a href="https://github.com/idealvin/co/tree/master/src/co/impl">hook</a> 的源码实现。</p>
<h4 id="1645-基于协程的一般网络编程模式">16.4.5 基于协程的一般网络编程模式</h4>
<p>协程可以实现高性能的同步网络编程方式。以 TCP 程序为例，服务端一般采用一个连接一个协程的模式，为每个连接创建新的协程，在协程中处理连接上的数据；客户端没必要一个连接一个协程，一般使用连接池，多个协程共用连接池中的连接。</p>
<ul>
<li>服务端处理连接数据的一般模式:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">server_fun</span>() {
    <span style="color:#66d9ef">while</span> (true) {
        co<span style="color:#f92672">::</span>recv(...);  <span style="color:#75715e">// 接收客户端请求数据
</span><span style="color:#75715e"></span>        process(...);   <span style="color:#75715e">// 业务处理
</span><span style="color:#75715e"></span>        co<span style="color:#f92672">::</span>send(...);  <span style="color:#75715e">// 发送结果到客户端
</span><span style="color:#75715e"></span>    }
    co<span style="color:#f92672">::</span>close(...);     <span style="color:#75715e">// 关闭 socket
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>客户端处理连接数据的一般模式:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">client_fun</span>() {
    co<span style="color:#f92672">::</span>send(...);   <span style="color:#75715e">// 发送请求数据到服务端
</span><span style="color:#75715e"></span>    co<span style="color:#f92672">::</span>recv(...);   <span style="color:#75715e">// 接收服务端响应数据
</span><span style="color:#75715e"></span>    process(...);    <span style="color:#75715e">// 业务处理
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="1646-基于协程的-tcp-serverclient-示例">16.4.6 基于协程的 tcp server/client 示例</h4>
<ul>
<li>server 代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Connection</span> {
    sock_t fd;   <span style="color:#75715e">// conn fd
</span><span style="color:#75715e"></span>    fastring ip; <span style="color:#75715e">// peer ip
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> port;    <span style="color:#75715e">// peer port
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">on_new_connection</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p) {
    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Connection<span style="color:#f92672">&gt;</span> conn((Connection<span style="color:#f92672">*</span>)p);
    sock_t fd <span style="color:#f92672">=</span> conn<span style="color:#f92672">-&gt;</span>fd;
    co<span style="color:#f92672">::</span>set_tcp_keepalive(fd);
    co<span style="color:#f92672">::</span>set_tcp_nodelay(fd);
    
    <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };

    <span style="color:#66d9ef">while</span> (true) {
        <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> co<span style="color:#f92672">::</span>recv(fd, buf, <span style="color:#ae81ff">4</span>);
        <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {          <span style="color:#75715e">// 客户端关闭了连接
</span><span style="color:#75715e"></span>            co<span style="color:#f92672">::</span>close(fd);     <span style="color:#75715e">// 调用 close 正常关闭连接
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {  <span style="color:#75715e">// 异常错误，直接 reset 连接
</span><span style="color:#75715e"></span>            co<span style="color:#f92672">::</span>reset_tcp_socket(fd, <span style="color:#ae81ff">1024</span>);
            <span style="color:#66d9ef">break</span>;
        } <span style="color:#66d9ef">else</span> {
            LOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;recv &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buf;
            LOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;send pong&#34;</span>;
            co<span style="color:#f92672">::</span>send(fd, <span style="color:#e6db74">&#34;pong&#34;</span>, <span style="color:#ae81ff">4</span>);
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">server_fun</span>() {
    sock_t fd <span style="color:#f92672">=</span> co<span style="color:#f92672">::</span>tcp_socket();
    co<span style="color:#f92672">::</span>set_reuseaddr(fd);

    sock_t connfd;
    <span style="color:#66d9ef">int</span> addrlen <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(sockaddr_in);
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> addr;
    co<span style="color:#f92672">::</span>init_ip_addr(<span style="color:#f92672">&amp;</span>addr, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#ae81ff">7788</span>);

    co<span style="color:#f92672">::</span>bind(fd, <span style="color:#f92672">&amp;</span>addr, <span style="color:#66d9ef">sizeof</span>(addr));
    co<span style="color:#f92672">::</span>listen(fd, <span style="color:#ae81ff">1024</span>);

    <span style="color:#66d9ef">while</span> (true) {
        connfd <span style="color:#f92672">=</span> co<span style="color:#f92672">::</span>accept(fd, <span style="color:#f92672">&amp;</span>addr, <span style="color:#f92672">&amp;</span>addrlen);
        <span style="color:#66d9ef">if</span> (connfd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;

        Connection<span style="color:#f92672">*</span> conn <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Connection;
        conn<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> connfd;
        conn<span style="color:#f92672">-&gt;</span>ip <span style="color:#f92672">=</span> co<span style="color:#f92672">::</span>ip_str(<span style="color:#f92672">&amp;</span>addr);
        conn<span style="color:#f92672">-&gt;</span>port <span style="color:#f92672">=</span> ntoh16(addr.sin_port);

        <span style="color:#75715e">// 为每个客户端连接创建一个新协程，在协程中处理连接上的数据
</span><span style="color:#75715e"></span>        co<span style="color:#f92672">::</span>go(on_new_connection, conn);
    }
}

go(server_fun);  <span style="color:#75715e">// 启动 server 协程
</span></code></pre></div><ul>
<li>client 代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">client_fun</span>() {
    sock_t fd <span style="color:#f92672">=</span> co<span style="color:#f92672">::</span>tcp_socket();

    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> addr;
    co<span style="color:#f92672">::</span>init_ip_addr(<span style="color:#f92672">&amp;</span>addr, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#ae81ff">7788</span>);

    co<span style="color:#f92672">::</span>connect(fd, <span style="color:#f92672">&amp;</span>addr, <span style="color:#66d9ef">sizeof</span>(addr), <span style="color:#ae81ff">3000</span>);
    co<span style="color:#f92672">::</span>set_tcp_nodelay(fd);

    <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">7</span>; <span style="color:#f92672">++</span>i) {
        co<span style="color:#f92672">::</span>sleep(<span style="color:#ae81ff">1000</span>);
        LOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;send ping&#34;</span>;
        co<span style="color:#f92672">::</span>send(fd, <span style="color:#e6db74">&#34;ping&#34;</span>, <span style="color:#ae81ff">4</span>);
        co<span style="color:#f92672">::</span>recv(fd, buf, <span style="color:#ae81ff">4</span>);
        LOG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;recv &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buf;
    }

    co<span style="color:#f92672">::</span>close(fd);
}

go(client_fun);  <span style="color:#75715e">// 启动 client 协程
</span></code></pre></div><h3 id="165-协程的同步机制">16.5 协程的同步机制</h3>
<p>co 协程库实现了与线程类似的同步机制，熟悉多线程编程的开发人员，很容易从线程切换到协程编程。</p>
<h4 id="1651-协程锁comutex">16.5.1 协程锁(co::Mutex)</h4>
<p><code>co::Mutex</code> 与线程库中的 <code>Mutex</code> 类似，只是需要在协程环境中使用。协程锁获取失败时，调度线程会挂起当前协程，调度线程自身不会阻塞。</p>
<p>另外，co 还提供一个 <code>co::MutexGuard</code> 类，用法与线程库中的 <code>MutexGuard</code> 一样。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">co<span style="color:#f92672">::</span>Mutex mtx;
<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f1</span>() {
    co<span style="color:#f92672">::</span>MutexGuard g(mtx);
    <span style="color:#f92672">++</span>v;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f2</span>() {
    co<span style="color:#f92672">::</span>MutexGuard g(mtx);
    <span style="color:#f92672">--</span>v;
}

go(f1);
go(f2);
</code></pre></div><h4 id="1652-协程同步事件coevent">16.5.2 协程同步事件(co::Event)</h4>
<p><code>co::Event</code> 与线程库中的 <code>SyncEvent</code> 类似，但需要在协程环境中使用。调用 <code>wait()</code> 方法时，调度线程会挂起当前协程，调度线程自身不会阻塞。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">co<span style="color:#f92672">::</span>Event ev;
<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f1</span>() {
    <span style="color:#75715e">// ev.wait(100);  // 等待 100 ms
</span><span style="color:#75715e"></span>    ev.wait();        <span style="color:#75715e">// 永久等待
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) v <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f2</span>() {
    v <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    ev.signal();
}

go(f1);
go(f2);
</code></pre></div><h3 id="166-协程池">16.6 协程池</h3>
<h4 id="1661-copool">16.6.1 co::Pool</h4>
<p>线程支持 <code>TLS</code> 机制，协程也可以支持类似的 <code>CLS</code> 机制，但考虑到系统中可能创建上百万协程，CLS 似乎不怎么高效，co 最终放弃了 CLS，取而代之实现了 <code>co::Pool</code> 类:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Pool</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Pool();
    Pool(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>()<span style="color:#f92672">&gt;&amp;&amp;</span> ccb, std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;&amp;&amp;</span> dcb, size_t cap<span style="color:#f92672">=</span>(size_t)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">pop</span>();
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p);

  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> _p;
};
</code></pre></div><ul>
<li>构造函数</li>
</ul>
<p>第二个构造函数中的参数 <code>ccb</code> 与 <code>dcb</code> 可用于创建、销毁元素，<code>cap</code> 则用于指定 pool 的最大容量。此处的最大容量是对单个线程而言，如 cap 设置为 1024，调度线程有 8 个，则总的最大容量实际上是 8192。另外注意，最大容量只有在同时指定了 dcb 时有效。</p>
<ul>
<li><code>pop</code></li>
</ul>
<p>此方法从 pool 中拉取一个元素。pool 为空时，若设置了 ccb，则调用 ccb 创建一个元素并返回；若没有设置 ccb，则返回 NULL。</p>
<ul>
<li><code>push</code></li>
</ul>
<p>此方法将元素放回 pool 中，若元素为 NULL，则直接忽略。若超过最大容量，且指定了 dcb，则直接调用 dcb 销毁元素，而不放入 pool 中。</p>
<p>co::Pool 类是协程安全的，调用 pop, push 方法不需要加锁，但必须在协程中调用。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">co<span style="color:#f92672">::</span>Pool p;

<span style="color:#66d9ef">void</span> f {
    Redis<span style="color:#f92672">*</span> rds <span style="color:#f92672">=</span> (Redis<span style="color:#f92672">*</span>) p.pop();     <span style="color:#75715e">// 从 pool 中拉取一个 redis 连接
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (rds <span style="color:#f92672">==</span> NULL) rds <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Redis;  <span style="color:#75715e">// pool 为空时，创建新的 redis 连接
</span><span style="color:#75715e"></span>
    rds<span style="color:#f92672">-&gt;</span>get(<span style="color:#e6db74">&#34;xx&#34;</span>);                    <span style="color:#75715e">// 调用 redis 的 get 方法
</span><span style="color:#75715e"></span>    p.push(rds);                       <span style="color:#75715e">// 用完 redis，放回 pool 中
</span><span style="color:#75715e"></span>}

go(f);
</code></pre></div><h4 id="1662-copoolguard">16.6.2 co::PoolGuard</h4>
<p><code>co::PoolGuard</code> 是一个模板类，它在构造时从 co::Pool 拉取元素，析构时将元素放回 co::Pool 中。另外, 它还重载了 <code>operator-&gt;</code>，可以像智能指针一样使用它。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 指定 ccb, dcb，用于 Redis 的自动创建与销毁
</span><span style="color:#75715e"></span>co<span style="color:#f92672">::</span>Pool p(
    []() { <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) <span style="color:#66d9ef">new</span> Redis; },  <span style="color:#75715e">// 指定 ccb
</span><span style="color:#75715e"></span>    [](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p) { <span style="color:#66d9ef">delete</span> (Redis<span style="color:#f92672">*</span>)p; }    <span style="color:#75715e">// 指定 dcb
</span><span style="color:#75715e"></span>);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
    co<span style="color:#f92672">::</span>PoolGuard<span style="color:#f92672">&lt;</span>Redis<span style="color:#f92672">&gt;</span> rds(p);  <span style="color:#75715e">// rds 可视为一个 Redis* 指针
</span><span style="color:#75715e"></span>    rds<span style="color:#f92672">-&gt;</span>get(<span style="color:#e6db74">&#34;xx&#34;</span>);               <span style="color:#75715e">// 调用 redis 的 get 方法
</span><span style="color:#75715e"></span>}

go(f);
</code></pre></div><p>使用 CLS 机制，100w 协程需要建立 100w 连接，但使用 pool 机制，100w 协程可能只需要共用少量的连接。Pool 看起来比 CLS 更高效、更合理，这也是本协程库不支持 CLS 的原因。</p>
<h3 id="167-配置项">16.7 配置项</h3>
<p>co 库支持的配置项如下:</p>
<ul>
<li>
<p>co_sched_num</p>
<p>调度线程数，默认为系统 CPU 核数，目前的实现中，这个值必须 &lt;= CPU 核数。</p>
</li>
<li>
<p>co_stack_size</p>
<p>协程栈大小，默认为 1M。每个调度线程都会分配一个栈，调度线程内的协程共用这个栈。</p>
</li>
<li>
<p>co_max_recv_size</p>
<p><code>co::recv</code> 一次能接收的最大数据长度，默认为 1M，超过此大小，分批接收。</p>
</li>
<li>
<p>co_max_send_size</p>
<p><code>co::send</code> 一次能发送的最大数据长度，默认为 1M，超过此大小，分批发送。</p>
</li>
</ul>
<h2 id="17-网络库so">17. 网络库(so)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/so.h">co/so.h</a>.</p>
<p><code>so</code> 是基于协程的网络库，包含 <code>tcp</code>, <code>http</code>, <code>rpc</code> 三个模块。</p>
<h3 id="171-tcp-编程">17.1 TCP 编程</h3>
<p><a href="https://github.com/idealvin/co/blob/master/include/co/so/tcp.h">so/tcp</a> 模块实现了 <code>tcp::Server</code> 与 <code>tcp::Client</code> 类，它们同时支持 <code>ipv4</code> 与 <code>ipv6</code>，可用于一般性的 TCP 编程。</p>
<h4 id="1711-tcpserverhttpsgithubcomidealvincoblobmasterincludecosotcph">17.1.1 <a href="https://github.com/idealvin/co/blob/master/include/co/so/tcp.h">tcp::Server</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> tcp {
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Connection</span> {
    sock_t fd;   <span style="color:#75715e">// conn fd
</span><span style="color:#75715e"></span>    fastring ip; <span style="color:#75715e">// peer ip
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> port;    <span style="color:#75715e">// peer port
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p;     <span style="color:#75715e">// pointer to Server where this connection was accepted
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Server</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Server(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ip, <span style="color:#66d9ef">int</span> port)
        <span style="color:#f92672">:</span> _ip((ip <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>ip) <span style="color:#f92672">?</span> ip : <span style="color:#e6db74">&#34;0.0.0.0&#34;</span>), _port(port) {
    }

    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Server() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span>() {
        go(<span style="color:#f92672">&amp;</span>Server<span style="color:#f92672">::</span>loop, <span style="color:#66d9ef">this</span>);
    }

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">on_connection</span>(Connection<span style="color:#f92672">*</span> conn) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    fastring _ip;
    uint32 _port;

  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> loop();
};
} <span style="color:#75715e">// tcp
</span></code></pre></div><p>tcp::Server 采用一个连接一个协程的模型，调用 <code>start()</code> 方法即进入事件循环，接收到新连接时，就创建一个协程，在协程中调用 <code>on_connection()</code> 方法，处理连接上的数据。</p>
<p>此类只能做为基类使用，用户需要继承此类，并实现 on_connection() 方法，注意参数 <code>conn</code> 是动态分配的，用户使用完后需要 delete 掉。</p>
<p><code>co/test</code> 中有一个 demo，基于 tcp::Server 实现了一个简单的 pingpong server，源码见 <a href="https://github.com/idealvin/co/blob/master/test/so/pingpong.cc">pingpong.cc</a>。</p>
<h4 id="1712-tcpclienthttpsgithubcomidealvincoblobmasterincludecosotcph">17.1.2 <a href="https://github.com/idealvin/co/blob/master/include/co/so/tcp.h">tcp::Client</a></h4>
<p>tcp::Client 必须在协程环境中使用，用户需要手动调用 <code>connect()</code> 方法建立连接。建议在调用 <code>recv</code>, <code>send</code> 之前，判断连接是否建立，没有的话，就调用 connect() 建立连接，这种方式容易实现自动重连。</p>
<p>一个 tcp::Client 对应一个连接，不要同时在多个协程中使用同一个 tcp::Client 对象。co 协程库理论上支持两个协程同时使用一个连接，一个协程 recv，一个协程 send，但不推荐这种用法。标准的做法是，recv 与 send 都在同一个协程中完成，以实现同步的编码方式。</p>
<p>一般建议将 tcp::Client 放到 <code>co::Pool</code> 中，多个协程共用 pool 中的连接。对每个协程而言，需要时即从 pool 中取出一个空闲连接，用完后再放回 pool 中，这种方式可以减少所需的连接数。</p>
<p>tcp::Client 的具体用法，可以参考 <a href="https://github.com/idealvin/co/blob/master/test/so/pingpong.cc">pingpong.cc</a> 中的 <code>client_fun()</code>，另外还可以参考 <a href="https://github.com/idealvin/co/blob/master/include/co/so/http.h">http::Client</a> 与 <a href="https://github.com/idealvin/co/blob/master/src/so/rpc.cc">rpc::Client</a> 的实现。</p>
<h3 id="172-http-编程">17.2 HTTP 编程</h3>
<p><a href="https://github.com/idealvin/co/blob/master/include/co/so/http.h">so/http</a> 模块基于 <code>so/tcp</code> 模块实现了 <code>http::Server</code> 类与 <code>http::Client</code> 类，同时还提供一个 <code>so::easy()</code> 方法，用于快速的创建静态 web server。</p>
<h4 id="1721-实现一个简单的-http-server">17.2.1 实现一个简单的 http server</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">http<span style="color:#f92672">::</span>Server serv(<span style="color:#e6db74">&#34;0.0.0.0&#34;</span>, <span style="color:#ae81ff">80</span>);

serv.on_req(
    [](<span style="color:#66d9ef">const</span> http<span style="color:#f92672">::</span>Req<span style="color:#f92672">&amp;</span> req, http<span style="color:#f92672">::</span>Res<span style="color:#f92672">&amp;</span> res) {
        <span style="color:#66d9ef">if</span> (req.is_method_get()) {
            <span style="color:#66d9ef">if</span> (req.url() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;/hello&#34;</span>) {
                res.set_status(<span style="color:#ae81ff">200</span>);
                res.set_body(<span style="color:#e6db74">&#34;hello world&#34;</span>);
            } <span style="color:#66d9ef">else</span> {
                res.set_status(<span style="color:#ae81ff">404</span>);
            }
        } <span style="color:#66d9ef">else</span> {
            res.set_status(<span style="color:#ae81ff">501</span>);
        }
    }
);

serv.start();
</code></pre></div><p>用户只需指定 ip 和端口，调用 <code>on_req()</code> 方法注册一个用于处理 HTTP 请求的 callback，然后就可以调用 <code>start()</code> 方法启动 server。</p>
<p><code>co/test</code> 提供了一个简单的 <a href="https://github.com/idealvin/co/blob/master/test/so/http_serv.cc">demo</a>，读者可以按下述方式编译运行:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">xmake -b http_serv
xmake r http_serv
</code></pre></div><p>启动 http server 后，可以在浏览器的地址栏中输入 <code>127.0.0.1/hello</code> 看结果。</p>
<h4 id="1722-实现一个静态-web-server">17.2.2 实现一个静态 web server</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/flag.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/log.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/so.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
DEF_string(d, <span style="color:#e6db74">&#34;.&#34;</span>, <span style="color:#e6db74">&#34;root dir&#34;</span>); <span style="color:#75715e">// 指定 web server 根目录
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv) {
    flag<span style="color:#f92672">::</span>init(argc, argv);
    log<span style="color:#f92672">::</span>init();

    so<span style="color:#f92672">::</span>easy(FLG_d.c_str()); <span style="color:#75715e">// mum never have to worry again
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><code>co/test</code> 中的 <a href="https://github.com/idealvin/co/blob/master/test/so/easy.cc">easy.cc</a> 即利用 <code>so::easy()</code> 实现了一个 web server，可以编译运行如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">xmake -b easy
xmake r easy -d xxx  <span style="color:#75715e"># xxx 作为 web server 的根目录</span>
</code></pre></div><h4 id="1723-http-client-的用法">17.2.3 http client 的用法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">http<span style="color:#f92672">::</span>Client cli(<span style="color:#e6db74">&#34;www.xxx.com&#34;</span>, <span style="color:#ae81ff">80</span>);
http<span style="color:#f92672">::</span>Req req;
http<span style="color:#f92672">::</span>Res res;

req.set_method_get();
req.set_url(<span style="color:#e6db74">&#34;/&#34;</span>);
cli.call(req, res); <span style="color:#75715e">// 获取 www.xxx.com 首页
</span><span style="color:#75715e"></span>
fastring s <span style="color:#f92672">=</span> res.body();
</code></pre></div><p>上述代码中，利用 <code>http::Req</code> 与 <code>http::Res</code> 类，用户可以精准的控制各种细节。如果想偷懒的话，也可以写成下面这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">http<span style="color:#f92672">::</span>Client cli(<span style="color:#e6db74">&#34;www.xxx.com&#34;</span>, <span style="color:#ae81ff">80</span>);
fastring s <span style="color:#f92672">=</span> cli.get(<span style="color:#e6db74">&#34;/&#34;</span>);
fastring x <span style="color:#f92672">=</span> cli.post(<span style="color:#e6db74">&#34;/url&#34;</span>, <span style="color:#e6db74">&#34;body&#34;</span>);
</code></pre></div><p>http::Client 继承于 tcp::Client，必须在协程中使用。 http::Client 会在 <code>call()</code> 方法中自动建立连接，无需用户手动调用 connect()。</p>
<p><code>co/test</code> 提供了一个简单的 <a href="https://github.com/idealvin/co/blob/master/test/so/http_cli.cc">demo</a>，可以按下述方式编译运行:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">xmake -b http_cli
xmake r http_cli -ip<span style="color:#f92672">=</span>github.com -port<span style="color:#f92672">=</span><span style="color:#ae81ff">80</span>
</code></pre></div><h4 id="1724-配置项">17.2.4 配置项</h4>
<ul>
<li>
<p>http_max_header_size</p>
<p>指定 http header 部分的最大长度，默认为 <code>4k</code>。</p>
</li>
<li>
<p>http_max_body_size</p>
<p>指定 http body 部分的最大长度，默认为 <code>8M</code>。</p>
</li>
<li>
<p>http_recv_timeout</p>
<p>指定 http recv 操作的超时时间，单位毫秒，默认为 <code>1024 ms</code>。</p>
</li>
<li>
<p>http_send_timeout</p>
<p>指定 http send 操作的超时时间，单位毫秒，默认为 <code>1024 ms</code>。</p>
</li>
<li>
<p>http_conn_timeout</p>
<p>指定 http connect 操作的超时时间，单位毫秒，默认为 <code>3000 ms</code>。</p>
</li>
<li>
<p>http_conn_idle_sec</p>
<p>指定 http server 空闲连接的超时时间，单位为秒，默认为 <code>180</code> 秒。</p>
</li>
<li>
<p>http_max_idle_conn</p>
<p>指定 http server 最大空闲连接数，默认为 <code>128</code>。</p>
</li>
<li>
<p>http_log</p>
<p>http 日志开关，默认为 <code>true</code>。(注意日志只打印 http 的头部)</p>
</li>
</ul>
<h3 id="173-rpc-框架">17.3 rpc 框架</h3>
<p><a href="https://github.com/idealvin/co/blob/master/include/co/so/rpc.h">so/rpc</a> 模块基于 <code>so/tcp</code> 实现了一个 rpc 框架，内部使用 <code>tcp/json</code> 作为传输协议，简单的测试显示单线程 qps 可以达到 <code>12w+</code>。json 与基于结构体的二进制协议相比，至少有下面几个好处：</p>
<ul>
<li>抓包可以直接看到传输的 json 对象，方便调试。</li>
<li>rpc 调用直接传输 json 对象，不需要定义各种结构体，大大减少代码量。</li>
<li>rpc 调用参数形式一致，固定为 <code>(const Json&amp; req, Json&amp; res)</code>，很容易自动生成代码。</li>
<li>可以实现通用的 rpc client，不需要为不同的 rpc server 生成不同的 client 代码。</li>
</ul>
<h4 id="1731-rpc-server-接口介绍">17.3.1 rpc server 接口介绍</h4>
<p>rpc server 的接口非常简单：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> rpc {
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Service</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Service() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">process</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 业务处理
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Server</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Server() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                <span style="color:#75715e">// 启动 rpc server 协程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_service</span>(Service<span style="color:#f92672">*</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// server 启动前必须先添加 Service 的实现
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// 创建一个 rpc server，passwd 非空时，客户端连接后需要进行密码认证
</span><span style="color:#75715e"></span>Server<span style="color:#f92672">*</span> <span style="color:#a6e22e">new_server</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ip, <span style="color:#66d9ef">int</span> port, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> passwd<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>);
} <span style="color:#75715e">// rpc
</span></code></pre></div><p><code>rpc::Server</code> 接收客户端连接，为每个连接创建一个新协程，新协程接收客户端请求，然后同步调用 <code>rpc::Service</code> 提供的 <code>process()</code> 方法处理请求，最后将结果发送回客户端。</p>
<p>具体的业务处理，需要继承 rpc::Service 并实现 process() 方法。实际上，process() 的代码是自动生成的，用户只需要实现具体的 rpc 调用方法。</p>
<h4 id="1732-rpc-proto-文件介绍">17.3.2 rpc proto 文件介绍</h4>
<p>下面是一个简单的 proto 文件 <code>hello_world.proto</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// # 或 // 表示 注释
</span><span style="color:#75715e"></span>package xx  <span style="color:#75715e">// namespace xx
</span><span style="color:#75715e"></span>
service HelloWorld {  
    hello,
    world,
}

hello.req {
    <span style="color:#e6db74">&#34;method&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;hello&#34;</span>
}

hello.res {
    <span style="color:#e6db74">&#34;method&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;hello&#34;</span>,
    <span style="color:#e6db74">&#34;err&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">200</span>,
    <span style="color:#e6db74">&#34;errmsg&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;200 ok&#34;</span>
}

world.req {
    <span style="color:#e6db74">&#34;method&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;world&#34;</span>
}

world.res {
    <span style="color:#e6db74">&#34;method&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;world&#34;</span>,
    <span style="color:#e6db74">&#34;err&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">200</span>,
    <span style="color:#e6db74">&#34;errmsg&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;200 ok&#34;</span>
}
</code></pre></div><p><code>package xx</code> 表示将代码生成到命名空间 <code>xx</code> 中，还可以用 package xx.yy.zz 生成嵌套命名空间。</p>
<p><code>service HelloWorld</code> 定义一个继承 rpc::Service 的 service 类，hello, world 是它提供的两个 rpc 方法。</p>
<p><code>hello.req, hello.res, world.req, world.res</code> 是请求参数及响应结果的示例，生成代码时不需要这些。</p>
<p>需要注意，一个 proto 文件只能定义一个 service。</p>
<h4 id="1733-rpc-代码生成器">17.3.3 rpc 代码生成器</h4>
<p>代码生成器源码见 <a href="https://github.com/idealvin/co/tree/master/gen">co/gen</a> 目录，可按下述方法构建 <code>gen</code>，并根据 proto 文件自动生成代码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">xmake -b gen           <span style="color:#75715e"># 构建 gen</span>
gen hello_world.proto  <span style="color:#75715e"># 生成代码</span>
</code></pre></div><p>下面是生成的 C++ 头文件 <code>hello_world.h</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#pragma once
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/so/rpc.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;co/hash.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> xx {

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HelloWorld</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> rpc<span style="color:#f92672">::</span>Service {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span> (HelloWorld<span style="color:#f92672">::*</span>Fun)(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span>, Json<span style="color:#f92672">&amp;</span>);

    HelloWorld() {
        _methods[hash64(<span style="color:#e6db74">&#34;ping&#34;</span>)] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>HelloWorld<span style="color:#f92672">::</span>ping;
        _methods[hash64(<span style="color:#e6db74">&#34;hello&#34;</span>)] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>HelloWorld<span style="color:#f92672">::</span>hello;
        _methods[hash64(<span style="color:#e6db74">&#34;world&#34;</span>)] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>HelloWorld<span style="color:#f92672">::</span>world;
    }

    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>HelloWorld() {}

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">process</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) {
        Json<span style="color:#f92672">&amp;</span> method <span style="color:#f92672">=</span> req[<span style="color:#e6db74">&#34;method&#34;</span>];
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>method.is_string()) {
            res.add_member(<span style="color:#e6db74">&#34;err&#34;</span>, <span style="color:#ae81ff">400</span>);
            res.add_member(<span style="color:#e6db74">&#34;errmsg&#34;</span>, <span style="color:#e6db74">&#34;400 req has no method&#34;</span>);
            <span style="color:#66d9ef">return</span>;
        }

        <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> _methods.find(hash64(method.get_string(), method.size()));
        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> _methods.end()) {
            res.add_member(<span style="color:#e6db74">&#34;err&#34;</span>, <span style="color:#ae81ff">404</span>);
            res.add_member(<span style="color:#e6db74">&#34;errmsg&#34;</span>, <span style="color:#e6db74">&#34;404 method not found&#34;</span>);
            <span style="color:#66d9ef">return</span>;
        }

        (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;*</span>it<span style="color:#f92672">-&gt;</span>second)(req, res);
    }

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ping</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) {
        res.add_member(<span style="color:#e6db74">&#34;method&#34;</span>, <span style="color:#e6db74">&#34;ping&#34;</span>);
        res.add_member(<span style="color:#e6db74">&#34;err&#34;</span>, <span style="color:#ae81ff">200</span>);
        res.add_member(<span style="color:#e6db74">&#34;errmsg&#34;</span>, <span style="color:#e6db74">&#34;pong&#34;</span>);
    }
    
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">world</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>uint64, Fun<span style="color:#f92672">&gt;</span> _methods;
};

} <span style="color:#75715e">// xx
</span></code></pre></div><p>可以看到 HelloWrold 的构造函数已经将 hello, world 方法注册到内部的 map 中，process() 方法根据 req 中的 <code>method</code> 字段，调用对应的 rpc 方法。用户只需继承 <code>HelloWorld</code> 类，实现具体进行业务处理的 hello, world 方法即可。</p>
<p>业务处理方法可能在不同的线程中调用，实现时需要注意线程安全性。业务处理方法内部需要连接到其他网络服务时，可以用协程安全的 <code>co::Pool</code> 管理这些网络连接。</p>
<p>生成的头文件可以直接放到 server 代码所在目录，客户端不需要用到。客户端只需参考 proto 文件中的 req/res 定义，就知道怎么构造 req 发起 rpc 调用了。</p>
<h4 id="1734-实现-rpc-server">17.3.4 实现 rpc server</h4>
<p>下面的示例代码 <code>hello_world.cc</code> 给出了一个简单的实现:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;hello_world.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> xx {

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HelloWorldImpl</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> HelloWorld {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    HelloWorldImpl() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>HelloWorldImpl() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) {
        res.add_member(<span style="color:#e6db74">&#34;method&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>);
        res.add_member(<span style="color:#e6db74">&#34;err&#34;</span>, <span style="color:#ae81ff">200</span>);
        res.add_member(<span style="color:#e6db74">&#34;errmsg&#34;</span>, <span style="color:#e6db74">&#34;200 ok&#34;</span>);
    }

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">world</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) {
        res.add_member(<span style="color:#e6db74">&#34;method&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span>);
        res.add_member(<span style="color:#e6db74">&#34;err&#34;</span>, <span style="color:#ae81ff">200</span>);
        res.add_member(<span style="color:#e6db74">&#34;errmsg&#34;</span>, <span style="color:#e6db74">&#34;200 ok&#34;</span>);
    }
};

} <span style="color:#75715e">// xx
</span></code></pre></div><p>完成上述的业务实现后，就可以启动 rpc server，一般只需要如下的三行代码:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">rpc<span style="color:#f92672">::</span>Server<span style="color:#f92672">*</span> server <span style="color:#f92672">=</span> rpc<span style="color:#f92672">::</span>new_server(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#ae81ff">7788</span>, <span style="color:#e6db74">&#34;passwd&#34;</span>);
server<span style="color:#f92672">-&gt;</span>add_service(<span style="color:#66d9ef">new</span> xx<span style="color:#f92672">::</span>HelloWorldImpl);
server<span style="color:#f92672">-&gt;</span>start();
</code></pre></div><p>注意调用 <code>start()</code> 方法会创建一个协程，server 在协程中运行，防止主线程退出是用户需要关心的事。</p>
<h4 id="1735-rpc-client">17.3.5 rpc client</h4>
<p>rpc client 的接口如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Client</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Client() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ping</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// send a heartbeat
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">const</span> Json<span style="color:#f92672">&amp;</span> req, Json<span style="color:#f92672">&amp;</span> res) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};

Client<span style="color:#f92672">*</span> <span style="color:#a6e22e">new_client</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ip, <span style="color:#66d9ef">int</span> port, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> passwd<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>);
} <span style="color:#75715e">// rpc
</span></code></pre></div><p><code>rpc::new_client()</code> 创建一个 rpc client，服务端若设置了密码，客户端需要带上密码进行认证。</p>
<p><code>call()</code> 方法发起 rpc 调用，不同的 rpc 请求可以用 req 中的 method 字段标志。</p>
<p><code>ping()</code> 方法用于给 server 端发送心跳。</p>
<ul>
<li>特别提醒
<ul>
<li>rpc::Client 创建时，并没有立即建立连接，第一次发起 rpc 请求才会建立连接。</li>
<li><code>delete rpc::Client</code>会关闭连接，这个操作需要在协程内进行。</li>
</ul>
</li>
</ul>
<p>下面是一个简单的 rpc client 示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">client_fun</span>() {
    rpc<span style="color:#f92672">::</span>Client<span style="color:#f92672">*</span> c <span style="color:#f92672">=</span> rpc<span style="color:#f92672">::</span>new_client(<span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#ae81ff">7788</span>, <span style="color:#e6db74">&#34;passwd&#34;</span>);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i) {
        Json req, res;
        req.add_member(<span style="color:#e6db74">&#34;method&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>);
        c<span style="color:#f92672">-&gt;</span>call(req, res);  <span style="color:#75715e">// 调用 hello 方法
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">delete</span> c; <span style="color:#75715e">// 在协程内 delete，是安全关闭连接所需要的
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv) {
    go(client_fun); <span style="color:#75715e">// 创建协程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) sleep<span style="color:#f92672">::</span>sec(<span style="color:#ae81ff">7</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>需要注意，一个 <code>rpc::Client</code> 对应一个连接，不要在多个线程中使用同一个 rpc::Client。多线程环境中，可以使用 <code>co::Pool</code> 管理客户端连接，下面是一个例子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">co<span style="color:#f92672">::</span>Pool p(
    std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>rpc<span style="color:#f92672">::</span>new_client, <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>, <span style="color:#ae81ff">7788</span>, <span style="color:#e6db74">&#34;passwd&#34;</span>),
    [](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p) { <span style="color:#66d9ef">delete</span> (rpc<span style="color:#f92672">::</span>Client<span style="color:#f92672">*</span>) p; }
);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">client_fun</span>() {
    co<span style="color:#f92672">::</span>PoolGuard<span style="color:#f92672">&lt;</span>rpc<span style="color:#f92672">::</span>Client<span style="color:#f92672">&gt;</span> c(p);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i) {
        Json req, res;
        req.add_member(<span style="color:#e6db74">&#34;method&#34;</span>, <span style="color:#e6db74">&#34;hello&#34;</span>);
        c<span style="color:#f92672">-&gt;</span>call(req, res);  <span style="color:#75715e">// 调用 hello 方法
</span><span style="color:#75715e"></span>    }
}

<span style="color:#75715e">// 创建 8 个协程
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span>; <span style="color:#f92672">++</span>i) {
    go(client_fun);
}
</code></pre></div><h4 id="1736-配置项">17.3.6 配置项</h4>
<ul>
<li>
<p>rpc_max_msg_size</p>
<p>rpc 消息最大长度，默认为 <code>8M</code>。</p>
</li>
<li>
<p>rpc_recv_timeout</p>
<p>rpc 接收数据超时时间，单位为毫秒，默认 <code>1024</code> 毫秒。</p>
</li>
<li>
<p>rpc_send_timeout</p>
<p>rpc 发送数据超时时间，单位为毫秒，默认 <code>1024</code> 毫秒。</p>
</li>
<li>
<p>rpc_conn_timeout</p>
<p>rpc 连接超时时间，单位为毫秒，默认 <code>3000</code> 毫秒。</p>
</li>
<li>
<p>rpc_conn_idle_sec</p>
<p>rpc 空闲连接超时时间，单位为秒，默认 <code>180</code> 秒。一个连接超过此时间没有收到任何数据，server 可能会关掉此连接。</p>
</li>
<li>
<p>rpc_max_idle_conn</p>
<p>最大空闲连接数，默认为 <code>128</code>。连接数超过此值，server 会关掉一些空闲连接(rpc_conn_idle_sec 时间内没有接收到数据的连接)。</p>
</li>
<li>
<p>rpc_log</p>
<p>是否打印 rpc 日志，默认为 <code>true</code>。</p>
</li>
</ul>
<h2 id="18-hash-库hash">18. hash 库(hash)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/hash.h">co/hash.h</a>.</p>
<p><code>hash</code> 库提供了如下的几个函数：</p>
<ul>
<li>
<p>murmur_hash</p>
<p>返回结果为 <code>size_t</code> 类型，<code>std::hash&lt;fastring&gt;</code> 的实现即使用了此 hash 函数。</p>
</li>
<li>
<p>hash64</p>
</li>
</ul>
<p>计算 64 位的 hash 值，内部使用 <code>murmur 2 hash</code> 算法。</p>
<ul>
<li>hash32</li>
</ul>
<p>计算 32 位的 hash 值，32 位系统使用 murmur 2 的 32 位版本，64 位系统直接取 <code>hash64</code> 的低 32 位。</p>
<ul>
<li>md5sum</li>
</ul>
<p>计算字符串或指定长度数据的 md5 值，返回 <code>32</code> 字节的字符串。</p>
<ul>
<li>crc16</li>
</ul>
<p>计算字符串或指定长度数据的 crc16 值，实现取自 <a href="https://github.com/antirez/redis/">redis</a>。</p>
<ul>
<li>base64_encode</li>
</ul>
<p>base64 编码，不添加 <code>\r, \n</code>，实际应用中，没有必要添加。</p>
<ul>
<li>base64_decode</li>
</ul>
<p>base64 解码，解码失败时抛出 const char* 类型的异常。</p>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">uint64 h <span style="color:#f92672">=</span> hash64(s);               <span style="color:#75715e">// 计算字符串 s 的 hash 值 
</span><span style="color:#75715e"></span>uint64 h <span style="color:#f92672">=</span> hash64(s, n);            <span style="color:#75715e">// 计算指定长度数据的 hash 值 
</span><span style="color:#75715e"></span>uint32 h <span style="color:#f92672">=</span> hash32(s);               <span style="color:#75715e">// 计算 32 位 hash 值
</span><span style="color:#75715e"></span>fastring s <span style="color:#f92672">=</span> md5sum(<span style="color:#e6db74">&#34;hello world&#34;</span>); <span style="color:#75715e">// 计算字符串的 md5，返回结果为 32 字节
</span><span style="color:#75715e"></span>uint16 x <span style="color:#f92672">=</span> crc16(<span style="color:#e6db74">&#34;hello world&#34;</span>);    <span style="color:#75715e">// 计算字符串的 crc16
</span><span style="color:#75715e"></span>fastring e <span style="color:#f92672">=</span> base64_encode(s);      <span style="color:#75715e">// base64 编码，不会抛出异常
</span><span style="color:#75715e"></span>fastring d <span style="color:#f92672">=</span> base64_decode(e);      <span style="color:#75715e">// base64 解码，d 应该与 s 相同
</span></code></pre></div><h2 id="19-path-库path">19. path 库(path)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/path.h">co/path.h</a>.</p>
<p><code>path</code> 库移植于 <a href="https://github.com/golang/go/blob/master/src/path/path.go">golang</a>，path 分隔符必须为 &lsquo;/'。</p>
<ul>
<li><code>path::clean()</code></li>
</ul>
<p>返回路径的最短等价形式，路径中连续的分隔符会被清除掉。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">path<span style="color:#f92672">::</span>clean(<span style="color:#e6db74">&#34;./x//y/&#34;</span>);     <span style="color:#75715e">// return &#34;x/y&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>clean(<span style="color:#e6db74">&#34;./x/..&#34;</span>);      <span style="color:#75715e">// return &#34;.&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>clean(<span style="color:#e6db74">&#34;./x/../..&#34;</span>);   <span style="color:#75715e">// return &#34;..&#34;
</span></code></pre></div><ul>
<li><code>path::join()</code></li>
</ul>
<p>将任意数量的字符串拼接成一个完整的路径，返回 path::clean() 处理后的结果。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">path<span style="color:#f92672">::</span>join(<span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#e6db74">&#34;y&#34;</span>, <span style="color:#e6db74">&#34;z&#34;</span>);  <span style="color:#75715e">// return &#34;x/y/z&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>join(<span style="color:#e6db74">&#34;/x/&#34;</span>, <span style="color:#e6db74">&#34;y&#34;</span>);     <span style="color:#75715e">// return &#34;/x/y&#34;
</span></code></pre></div><ul>
<li><code>path::split()</code></li>
</ul>
<p>将路径切分为 dir, file 两部分，若路径中不含分隔符，则 dir 部分为空。返回结果满足性质 <code>path = dir + file</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">path<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;/&#34;</span>);     <span style="color:#75715e">// -&gt; { &#34;/&#34;, &#34;&#34; }
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;/a&#34;</span>);    <span style="color:#75715e">// -&gt; { &#34;/&#34;, &#34;a&#34; }
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>split(<span style="color:#e6db74">&#34;/a/b&#34;</span>);  <span style="color:#75715e">// -&gt; { &#34;/a/&#34;, &#34;b&#34; }
</span></code></pre></div><ul>
<li><code>path::dir()</code></li>
</ul>
<p>返回路径的目录部分，返回 path::clean() 处理后的结果。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">path<span style="color:#f92672">::</span>dir(<span style="color:#e6db74">&#34;a&#34;</span>);      <span style="color:#75715e">// return &#34;.&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>dir(<span style="color:#e6db74">&#34;a/&#34;</span>);     <span style="color:#75715e">// return &#34;a&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>dir(<span style="color:#e6db74">&#34;/&#34;</span>);      <span style="color:#75715e">// return &#34;/&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>dir(<span style="color:#e6db74">&#34;/a&#34;</span>);     <span style="color:#75715e">// return &#34;/&#34;;
</span></code></pre></div><ul>
<li><code>path::base()</code></li>
</ul>
<p>返回路径最后的一个元素。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">path<span style="color:#f92672">::</span>base(<span style="color:#e6db74">&#34;&#34;</span>);      <span style="color:#75715e">// return &#34;.&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>base(<span style="color:#e6db74">&#34;/&#34;</span>);     <span style="color:#75715e">// return &#34;/&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>base(<span style="color:#e6db74">&#34;/a/&#34;</span>);   <span style="color:#75715e">// return &#34;a&#34;  忽略末尾的分隔符
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>base(<span style="color:#e6db74">&#34;/a&#34;</span>);    <span style="color:#75715e">// return &#34;a&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>base(<span style="color:#e6db74">&#34;/a/b&#34;</span>);  <span style="color:#75715e">// return &#34;b&#34;
</span></code></pre></div><ul>
<li><code>path::ext()</code></li>
</ul>
<p>函数返回路径中文件名的扩展名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">path<span style="color:#f92672">::</span>ext(<span style="color:#e6db74">&#34;/a.cc&#34;</span>);  <span style="color:#75715e">// return &#34;.cc&#34;
</span><span style="color:#75715e"></span>path<span style="color:#f92672">::</span>ext(<span style="color:#e6db74">&#34;/a.cc/&#34;</span>); <span style="color:#75715e">// return &#34;&#34;
</span></code></pre></div><h2 id="20-文件系统操作fs">20. 文件系统操作(fs)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fs.h">co/fs.h</a>.</p>
<p><code>fs</code> 库最小限度的实现了常用的文件系统操作，不同平台 path 分隔符建议统一使用 <code>'/'</code>。</p>
<h3 id="201-元数据操作">20.1 元数据操作</h3>
<ul>
<li>代码示例</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> x <span style="color:#f92672">=</span> fs<span style="color:#f92672">::</span>exists(path);  <span style="color:#75715e">// 判断文件是否存在
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> x <span style="color:#f92672">=</span> fs<span style="color:#f92672">::</span>isdir(path);   <span style="color:#75715e">// 判断文件是否为目录
</span><span style="color:#75715e"></span>int64 x <span style="color:#f92672">=</span> fs<span style="color:#f92672">::</span>mtime(path);  <span style="color:#75715e">// 获取文件的修改时间
</span><span style="color:#75715e"></span>int64 x <span style="color:#f92672">=</span> fs<span style="color:#f92672">::</span>fsize(path);  <span style="color:#75715e">// 获取文件的大小
</span><span style="color:#75715e"></span>
fs<span style="color:#f92672">::</span>mkdir(<span style="color:#e6db74">&#34;a/b&#34;</span>);           <span style="color:#75715e">// mkdir a/b
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>mkdir(<span style="color:#e6db74">&#34;a/b&#34;</span>, true);     <span style="color:#75715e">// mkdir -p a/b
</span><span style="color:#75715e"></span>
fs<span style="color:#f92672">::</span>remove(<span style="color:#e6db74">&#34;x/x.txt&#34;</span>);      <span style="color:#75715e">// rm x/x.txt
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>remove(<span style="color:#e6db74">&#34;a/b&#34;</span>);          <span style="color:#75715e">// rmdir a/b   删除空目录
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>remove(<span style="color:#e6db74">&#34;a/b&#34;</span>, true);    <span style="color:#75715e">// rm -rf a/b     
</span><span style="color:#75715e"></span>
fs<span style="color:#f92672">::</span>rename(<span style="color:#e6db74">&#34;a/b&#34;</span>, <span style="color:#e6db74">&#34;a/c&#34;</span>);   <span style="color:#75715e">// 重命名
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>symlink(<span style="color:#e6db74">&#34;/usr&#34;</span>, <span style="color:#e6db74">&#34;x&#34;</span>);   <span style="color:#75715e">// 软链接 x -&gt; /usr，windows 需要 admin 权限
</span></code></pre></div><h3 id="202-文件的基本读写操作">20.2 文件的基本读写操作</h3>
<p>fs 库实现了 <code>fs::file</code> 类，支持文件的基本读写操作。</p>
<ul>
<li>
<p>fs::file 类的特性</p>
<ul>
<li>支持<code>r, w, a, m</code>四种读写模式，前三种与 fopen 保持一致，<code>m</code>与<code>w</code>类似，但不会清空已存在文件的数据。</li>
<li>不支持缓存，直接读写文件。</li>
<li>支持<code>move</code>语义，可以将 file 对象直接放入 STL 容器中。</li>
</ul>
</li>
<li>
<p>代码示例</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fs<span style="color:#f92672">::</span>file f;               <span style="color:#75715e">// 后续可调用 f.open() 打开文件
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>file f(<span style="color:#e6db74">&#34;xx&#34;</span>, <span style="color:#e6db74">&#39;r&#39;</span>);    <span style="color:#75715e">// 读模式打开文件
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 自动关闭之前打开的文件
</span><span style="color:#75715e"></span>f.open(<span style="color:#e6db74">&#34;xx&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>);        <span style="color:#75715e">// 追加写，文件不存在时创建
</span><span style="color:#75715e"></span>f.open(<span style="color:#e6db74">&#34;xx&#34;</span>, <span style="color:#e6db74">&#39;w&#39;</span>);        <span style="color:#75715e">// 一般写，文件不存在时创建，文件存在时清空数据
</span><span style="color:#75715e"></span>f.open(<span style="color:#e6db74">&#34;xx&#34;</span>, <span style="color:#e6db74">&#39;m&#39;</span>);        <span style="color:#75715e">// 修改写，文件不存在时创建，文件存在时不清数据
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">if</span> (f) f.read(buf, <span style="color:#ae81ff">512</span>);  <span style="color:#75715e">// 读取最多 512 字节
</span><span style="color:#75715e"></span>f.write(buf, <span style="color:#ae81ff">32</span>);         <span style="color:#75715e">// 写入 32 字节
</span><span style="color:#75715e"></span>f.write(<span style="color:#e6db74">&#34;hello&#34;</span>);         <span style="color:#75715e">// 写入字符串
</span><span style="color:#75715e"></span>f.write(<span style="color:#e6db74">&#39;c&#39;</span>);             <span style="color:#75715e">// 写入单个字符
</span><span style="color:#75715e"></span>f.close();                <span style="color:#75715e">// 关闭文件，file 析构时会调用 close()
</span></code></pre></div><h3 id="203-文件流fsfstream">20.3 文件流(fs::fstream)</h3>
<p><code>fs::file</code> 不支持缓存，写小文件性能较差，为此，fs 库另外提供了 <code>fs::fstream</code> 类。</p>
<ul>
<li>
<p>fs::fstream 类的特性</p>
<ul>
<li>只写不读，仅支持<code>w, a</code>两种模式。</li>
<li>可以自定义缓存大小，默认为<code>8k</code>。</li>
<li>支持<code>move</code>语义，可将 fstream 对象放入 STL 容器中。</li>
</ul>
</li>
<li>
<p>代码示例</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">fs<span style="color:#f92672">::</span>fstream s;                    <span style="color:#75715e">// 默认缓存为 8k
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>fstream s(<span style="color:#ae81ff">4096</span>);              <span style="color:#75715e">// 指定缓存为 4k
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>fstream s(<span style="color:#e6db74">&#34;path&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>);       <span style="color:#75715e">// 追加模式，缓存默认为 8k
</span><span style="color:#75715e"></span>fs<span style="color:#f92672">::</span>fstream s(<span style="color:#e6db74">&#34;path&#34;</span>, <span style="color:#e6db74">&#39;w&#39;</span>, <span style="color:#ae81ff">4096</span>); <span style="color:#75715e">// 写模式，指定缓存为 4k
</span><span style="color:#75715e"></span>
s.open(<span style="color:#e6db74">&#34;path&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>);              <span style="color:#75715e">// 打开文件，自动关闭之前已经打开的文件
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (s) s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello world&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">23</span>;  <span style="color:#75715e">// 流式写
</span><span style="color:#75715e"></span>s.append(data, size);             <span style="color:#75715e">// 追加指定长度的数据
</span><span style="color:#75715e"></span>s.flush();                        <span style="color:#75715e">// 将缓存中数据写入文件
</span><span style="color:#75715e"></span>s.close();                        <span style="color:#75715e">// 关闭文件，析构时会自动关闭
</span></code></pre></div><h2 id="21-系统操作os">21. 系统操作(os)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/os.h">co/os.h</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">os<span style="color:#f92672">::</span>homedir();   <span style="color:#75715e">// 返回 home 目录路径
</span><span style="color:#75715e"></span>os<span style="color:#f92672">::</span>cwd();       <span style="color:#75715e">// 返回当前工作目录路径
</span><span style="color:#75715e"></span>os<span style="color:#f92672">::</span>exepath();   <span style="color:#75715e">// 返回当前进程路径
</span><span style="color:#75715e"></span>os<span style="color:#f92672">::</span>exename();   <span style="color:#75715e">// 返回当前进程名
</span><span style="color:#75715e"></span>os<span style="color:#f92672">::</span>pid();       <span style="color:#75715e">// 返回当前进程 id
</span><span style="color:#75715e"></span>os<span style="color:#f92672">::</span>cpunum();    <span style="color:#75715e">// 返回 cpu 核数
</span><span style="color:#75715e"></span>os<span style="color:#f92672">::</span>daemon();    <span style="color:#75715e">// 后台运行，仅支持 Linux 平台
</span></code></pre></div><h2 id="22-编译">22. 编译</h2>
<h3 id="xmake">xmake</h3>
<p><code>CO</code> 推荐使用 <a href="https://github.com/xmake-io/xmake">xmake</a> 进行编译。</p>
<ul>
<li>
<p>编译器</p>
<ul>
<li>Linux: <a href="https://gcc.gnu.org/projects/cxx-status.html#cxx11">gcc 4.8+</a></li>
<li>Mac: <a href="https://clang.llvm.org/cxx_status.html">clang 3.3+</a></li>
<li>Windows: <a href="https://visualstudio.microsoft.com/">vs2015+</a></li>
</ul>
</li>
<li>
<p>安装 xmake</p>
<p>windows, mac 与 debian/ubuntu 可以直接去 xmake 的 <a href="https://github.com/xmake-io/xmake/releases">release</a> 页面下载安装包，其他系统请参考 xmake 的 <a href="https://xmake.io/#/guide/installation">Installation</a> 说明。</p>
<p>xmake 在 linux 上默认禁止 root 用户编译，<a href="https://github.com/waruqi">ruki</a> 说不安全，可以在 <code>~/.bashrc</code> 中加上下面的一行，启用 root 编译:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">export XMAKE_ROOT<span style="color:#f92672">=</span>y
</code></pre></div></li>
<li>
<p>快速上手</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 所有命令都在 co 根目录执行，后面不再说明</span>
xmake       <span style="color:#75715e"># 默认编译 libco 与 gen</span>
xmake -a    <span style="color:#75715e"># 编译所有项目 (libco, gen, co/test, co/unitest)</span>
</code></pre></div></li>
<li>
<p>编译 libco</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">xmake build libco       <span style="color:#75715e"># 编译 libco</span>
xmake -b libco          <span style="color:#75715e"># 与上同</span>
</code></pre></div></li>
<li>
<p>编译及运行 unitest 代码</p>
<p><a href="https://github.com/idealvin/co/tree/master/unitest">co/unitest</a> 是单元测试代码，用于检验 libco 库功能的正确性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">xmake build unitest     <span style="color:#75715e"># build 可以简写为 -b</span>
xmake run unitest -a    <span style="color:#75715e"># 执行所有单元测试</span>
xmake r unitest -a      <span style="color:#75715e"># 同上</span>
xmake r unitest -os     <span style="color:#75715e"># 执行单元测试 os</span>
xmake r unitest -json   <span style="color:#75715e"># 执行单元测试 json</span>
</code></pre></div></li>
<li>
<p>编译及运行 test 代码</p>
<p><a href="https://github.com/idealvin/co/tree/master/test">co/test</a> 包含了一些测试代码。co/test 目录下增加 <code>xxx.cc</code> 源文件，然后在 co 根目录下执行 <code>xmake build xxx</code> 即可构建。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">xmake build flag             <span style="color:#75715e"># 编译 flag.cc</span>
xmake build log              <span style="color:#75715e"># 编译 log.cc</span>
xmake build json             <span style="color:#75715e"># 编译 json.cc</span>
xmake build rapidjson        <span style="color:#75715e"># 编译 rapidjson.cc</span>
xmake build rpc              <span style="color:#75715e"># 编译 rpc.cc</span>
xmake build easy             <span style="color:#75715e"># 编译 so/easy.cc</span>
xmake build pingpong         <span style="color:#75715e"># 编译 so/pingpong.cc</span>
  
xmake r flag -xz             <span style="color:#75715e"># 测试 flag 库</span>
xmake r log                  <span style="color:#75715e"># 测试 log 库</span>
xmake r log -cout            <span style="color:#75715e"># 终端也打印日志</span>
xmake r log -perf            <span style="color:#75715e"># log 库性能测试</span>
xmake r json                 <span style="color:#75715e"># 测试 json</span>
xmake r rapidjson            <span style="color:#75715e"># 测试 rapidjson</span>
xmake r rpc                  <span style="color:#75715e"># 启动 rpc server</span>
xmake r rpc -c               <span style="color:#75715e"># 启动 rpc client</span>
xmake r easy -d xxx          <span style="color:#75715e"># 启动 web server</span>
xmake r pingpong             <span style="color:#75715e"># pingpong server:   127.0.0.1:9988</span>
xmake r pingpong ip<span style="color:#f92672">=</span>::       <span style="color:#75715e"># pingpong server:   :::9988  (ipv6)</span>
xmake r pingpong -c ip<span style="color:#f92672">=</span>::1   <span style="color:#75715e"># pingpong client -&gt; ::1:9988</span>
</code></pre></div></li>
<li>
<p>编译 gen</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 建议将 gen 放到系统目录下(如 /usr/local/bin/).</span>
xmake build gen
gen hello_world.proto
</code></pre></div><p><code>proto</code> 文件格式可以参考 <a href="https://github.com/idealvin/co/blob/master/test/__/rpc/hello_world.proto">hello_world.proto</a>。</p>
</li>
<li>
<p>安装</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 默认安装头文件、libco、gen</span>
xmake install -o pkg          <span style="color:#75715e"># 打包安装到 pkg 目录</span>
xmake i -o pkg                <span style="color:#75715e"># 同上</span>
xmake install -o /usr/local   <span style="color:#75715e"># 安装到 /usr/local 目录</span>
</code></pre></div></li>
</ul>
<h3 id="cmake">cmake</h3>
<p><a href="https://github.com/izhengfan">izhengfan</a> 帮忙提供了 cmake 支持:</p>
<ul>
<li>默认只编译 <code>libco</code> 与 <code>gen</code>.</li>
<li>编译生成的库文件在 build/lib 目录下，可执行文件在 build/bin 目录下.</li>
<li>可以用 <code>BUILD_ALL</code> 指定编译所有项目.</li>
<li>可以用 <code>CMAKE_INSTALL_PREFIX</code> 指定安装目录.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">mkdir build <span style="color:#f92672">&amp;&amp;</span> cd build
cmake ..
cmake .. -DBUILD_ALL<span style="color:#f92672">=</span>ON -DCMAKE_INSTALL_PREFIX<span style="color:#f92672">=</span>pkg
make -j8
make install
</code></pre></div><!--
<div STYLE="page-break-after: always;"></div>
-->
<h2 id="23-结束语">23. 结束语</h2>
<p>这份文档其实还可以写得更详细一点，终因语言乏力、精力有限作罢，只能说声抱歉了。文档中难免有些疏漏、错误之处，敬请海涵与指正！</p>
<ul>
<li>
<p>有问题请提交到 <a href="https://github.com/idealvin/co/">github</a>.</p>
</li>
<li>
<p>赞助、商务合作请联系 <code>idealvin@qq.com</code>.</p>
</li>
<li>
<p><a href="https://idealvin.github.io/donate/">支持作者请扫码</a></p>
<p><img src="/images/wxzfb.png" alt="wechat & alipay" title="wechat &amp; alipay"></p>
</li>
</ul>


  <footer>
  



<nav class="fixed-nav">
  <span class="next">
    <a href=" /coding/2018/10/namespace-log/ ">&raquo;</a>
  </span>
</nav>
<nav class="post-nav">
  <ul>
     
    <li>
      <span class="prev">&rtrif; 上一篇 &emsp;</span>
      <a href="/coding/2020/07/co_en/">Documents for co v1.2</a>
    </li>
    
    
    <li>
      <span class="next">&rtrif; 下一篇 &emsp;</span>
      <a href="/coding/2018/10/namespace-log/">解决 namespace log 与 math 库 log() 函数的冲突</a>
    </li>
    
  </ul>
</nav>






<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.6.2/gitalk.min.css">
<script src="//cdn.bootcss.com/gitalk/1.6.2/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '78371628e00f43aff18e',
    clientSecret: '6905d0b807b7008ea04b420bb9fd9a7f390ec400',
    repo: 'gitalk',
    owner: 'idealvin',
    admin: ['idealvin'],
    id: location.pathname,
    language: 'zh-CN',
    distractionFreeMode: false
  })
  
  gitalk.render('gitalk-container');
</script>



  



<script src="//cdn.bootcss.com/highlight.js/10.1.2/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/10.1.2/languages/cpp.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/10.1.2/languages/bash.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/10.1.2/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">©2018-2020 <a href="/">Alvin Yih</a> | <a href="https://github.com/idealvin">Github</a></div>
  
  </footer>
  
   <div class="cnzz">
<script type="text/javascript">
  document.write(unescape("%3Cspan id='cnzz_stat_icon_1279117347'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279117347%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));
</script>
</div> 
  </article>
  
  
  </body>
</html>

